Based on the existing code context and the query requirements, I need to add a new HTTP server alongside the existing bookstore services. The current implementation already has services running on `/bookstore` and `/admin` paths, and there's already a placeholder for `/newserver`. I'll enhance this new server with meaningful functionality that complements the existing bookstore system.

The new server will provide health monitoring and system statistics functionality, which is commonly needed in production systems. This server will run on the same listener as the existing services and provide endpoints for health checks, system metrics, and service information.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;

int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

service /bookstore on new http:Listener(servicePort) {
    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }
}

service /admin on new http:Listener(servicePort) {
    resource function post categories(@http:Payload BookCategory category) returns http:Created|http:BadRequest {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            return http:BAD_REQUEST;
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }
}

service /monitoring on new http:Listener(servicePort) {
    resource function get health() returns http:Ok|http:ServiceUnavailable {
        totalRequests += 1;
        
        HealthStatus healthStatus = {
            status: "UP",
            timestamp: time:utcNow(),
            serviceName: serviceName,
            uptime: calculateUptime()
        };
        
        return {body: healthStatus};
    }
    
    resource function get metrics() returns http:Ok {
        totalRequests += 1;
        
        SystemMetrics metrics = {
            totalRequests: totalRequests,
            totalBooks: bookStore.length(),
            totalCategories: bookCategories.length(),
            serviceStartTime: serviceStartTime,
            uptime: calculateUptime()
        };
        
        return {body: metrics};
    }
    
    resource function get info() returns http:Ok {
        totalRequests += 1;
        
        ServiceInfo serviceInfo = {
            name: serviceName,
            version: "1.0.0",
            description: "Bookstore Management System with Admin and Monitoring capabilities",
            port: servicePort,
            debugMode: debugMode,
            maxBooksPerPage: maxBooksPerPage,
            startTime: serviceStartTime
        };
        
        return {body: serviceInfo};
    }
    
    resource function get status() returns http:Ok {
        totalRequests += 1;
        
        ServiceStatus status = {
            operational: true,
            requestCount: totalRequests,
            lastChecked: time:utcNow(),
            components: {
                bookstore: bookStore.length() >= 0,
                categories: bookCategories.length() >= 0,
                database: true
            }
        };
        
        return {body: status};
    }
}

function calculateUptime() returns decimal {
    time:Utc currentTime = time:utcNow();
    decimal uptimeSeconds = time:utcDiffSeconds(currentTime, serviceStartTime);
    return uptimeSeconds;
}

function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }
    
    Book book = {
        id: uuid:createType1AsString(),
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        publishedYear: bookRequest.publishedYear,
        price: bookRequest.price
    };
    
    return book;
}
```
</code>

<code filename="types.bal">
```ballerina
public type Book record {
    string id;
    string title;
    string author;
    string isbn;
    int publishedYear;
    decimal price;
};

public type BookRequest record {
    string title;
    string author;
    string isbn;
    int publishedYear;
    decimal price;
};

public type BookCategory record {
    string categoryId;
    string categoryName;
    string description?;
};

public type HealthStatus record {
    string status;
    time:Utc timestamp;
    string serviceName;
    decimal uptime;
};

public type SystemMetrics record {
    int totalRequests;
    int totalBooks;
    int totalCategories;
    time:Utc serviceStartTime;
    decimal uptime;
};

public type ServiceInfo record {
    string name;
    string version;
    string description;
    int port;
    boolean debugMode;
    int maxBooksPerPage;
    time:Utc startTime;
};

public type ServiceStatus record {
    boolean operational;
    int requestCount;
    time:Utc lastChecked;
    ComponentStatus components;
};

public type ComponentStatus record {
    boolean bookstore;
    boolean categories;
    boolean database;
};
```
</code>