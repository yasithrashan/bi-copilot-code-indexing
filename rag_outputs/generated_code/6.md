Based on the existing code context and the user's request to add a new HTTP server, I'll add a third HTTP service that runs on a different port (servicePort + 2) to complement the existing bookstore and admin services. This new server will provide additional functionality for managing book inventory and statistics.

<code filename="main.bal">
```ballerina
import ballerina/http;

configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";

int totalRequests = 0;
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

service /bookstore on new http:Listener(servicePort) {
    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }

    resource function get books() returns Book[] {
        totalRequests += 1;
        return bookStore.toArray();
    }
}

service /admin on new http:Listener(servicePort) {
    resource function post categories(@http:Payload BookCategory category) returns http:Created|http:BadRequest {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            return http:BAD_REQUEST;
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }

    resource function get statistics() returns json {
        totalRequests += 1;
        return {
            "totalRequests": totalRequests,
            "totalBooks": bookStore.length(),
            "totalCategories": bookCategories.length()
        };
    }
}

// New HTTP server on a different port
service /inventory on new http:Listener(servicePort + 2) {
    resource function get books/[string bookId]() returns Book|http:NotFound {
        totalRequests += 1;
        
        if bookStore.hasKey(bookId) {
            Book book = bookStore.get(bookId);
            return book;
        }
        return http:NOT_FOUND;
    }

    resource function put books/[string bookId]/quantity(@http:Payload QuantityUpdate quantityUpdate) returns http:Ok|http:NotFound|http:BadRequest {
        totalRequests += 1;

        if quantityUpdate.quantity < 0 {
            return http:BAD_REQUEST;
        }

        if bookStore.hasKey(bookId) {
            Book existingBook = bookStore.get(bookId);
            Book updatedBook = {
                id: existingBook.id,
                title: existingBook.title,
                author: existingBook.author,
                isbn: existingBook.isbn,
                price: existingBook.price,
                quantity: quantityUpdate.quantity
            };
            bookStore[bookId] = updatedBook;
            return http:OK;
        }
        return http:NOT_FOUND;
    }

    resource function get categories() returns BookCategory[] {
        totalRequests += 1;
        return bookCategories.toArray();
    }

    resource function delete books/[string bookId]() returns http:Ok|http:NotFound {
        totalRequests += 1;

        if bookStore.hasKey(bookId) {
            Book removedBook = bookStore.remove(bookId);
            return http:OK;
        }
        return http:NOT_FOUND;
    }
}

function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 || bookRequest.author.trim().length() == 0 {
        return error("Title and author are required");
    }
    
    if bookRequest.price < 0 || bookRequest.quantity < 0 {
        return error("Price and quantity must be non-negative");
    }

    string bookId = bookRequest.isbn;
    if bookId.trim().length() == 0 {
        return error("ISBN is required");
    }

    Book book = {
        id: bookId,
        title: bookRequest.title,
        author: bookRequest.author,
        isbn: bookRequest.isbn,
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return book;
}
```
</code>

<code filename="types.bal">
```ballerina
public type Book record {|
    string id;
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type BookRequest record {|
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type BookCategory record {|
    string categoryId;
    string categoryName;
    string description;
|};

public type QuantityUpdate record {|
    int quantity;
|};
```
</code>