Looking at the existing code, I can see there are already two services running on the same port (8080): `/bookstore` and `/admin`. I'll add a new HTTP server by creating a third service `/analytics` that provides analytics and monitoring capabilities for the bookstore system.

The new service will:
- Provide system analytics endpoints
- Track request statistics
- Offer health check functionality
- Display service information

Since all services are currently sharing the same HTTP listener on the configured port, I'll add the new service to the same listener to maintain consistency with the existing architecture.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;

int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

// HTTP Listener shared by all services
http:Listener httpListener = new http:Listener(servicePort);

service /bookstore on httpListener {
    resource function get books(int page = 1, int 'limit = maxBooksPerPage) returns PaginatedBooks|http:InternalServerError {
        totalRequests += 1;
        
        // Get all books as an array
        Book[] allBooks = bookStore.toArray();
        
        // Calculate pagination
        int startIndex = (page - 1) * 'limit;
        int endIndex = startIndex + 'limit;
        
        if startIndex >= allBooks.length() {
            PaginatedBooks paginatedResult = {
                books: [],
                totalBooks: allBooks.length(),
                currentPage: page,
                totalPages: (allBooks.length() + 'limit - 1) / 'limit
            };
            return paginatedResult;
        }
        
        if endIndex > allBooks.length() {
            endIndex = allBooks.length();
        }
        
        Book[] paginatedBooks = [];
        int i = startIndex;
        while i < endIndex {
            paginatedBooks.push(allBooks[i]);
            i += 1;
        }
        
        PaginatedBooks paginatedResult = {
            books: paginatedBooks,
            totalBooks: allBooks.length(),
            currentPage: page,
            totalPages: (allBooks.length() + 'limit - 1) / 'limit
        };
        
        return paginatedResult;
    }

    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }

    resource function get books/[string bookId]() returns Book|http:NotFound {
        totalRequests += 1;
        
        if bookStore.hasKey(key = bookId) {
            Book book = bookStore.get(k = bookId);
            return book;
        }
        
        return http:NOT_FOUND;
    }
}

service /admin on httpListener {
    resource function post categories(@http:Payload BookCategory category) returns http:Created|http:BadRequest {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            return http:BAD_REQUEST;
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }

    resource function get categories() returns BookCategory[] {
        totalRequests += 1;
        return bookCategories.toArray();
    }

    resource function get stats() returns AdminStats {
        totalRequests += 1;
        
        time:Utc currentTime = time:utcNow();
        time:Seconds uptime = time:utcDiffSeconds(currentTime, serviceStartTime);
        
        AdminStats stats = {
            totalBooks: bookStore.length(),
            totalCategories: bookCategories.length(),
            totalRequests: totalRequests,
            uptimeSeconds: uptime,
            serviceName: serviceName
        };
        
        return stats;
    }
}

// New HTTP server - Analytics service
service /analytics on httpListener {
    resource function get health() returns HealthStatus {
        totalRequests += 1;
        
        time:Utc currentTime = time:utcNow();
        time:Seconds uptime = time:utcDiffSeconds(currentTime, serviceStartTime);
        
        HealthStatus healthStatus = {
            status: "UP",
            timestamp: currentTime,
            uptime: uptime,
            version: "1.0.0"
        };
        
        return healthStatus;
    }

    resource function get metrics() returns SystemMetrics {
        totalRequests += 1;
        
        time:Utc currentTime = time:utcNow();
        time:Seconds uptime = time:utcDiffSeconds(currentTime, serviceStartTime);
        
        SystemMetrics metrics = {
            totalRequests: totalRequests,
            totalBooks: bookStore.length(),
            totalCategories: bookCategories.length(),
            uptime: uptime,
            averageRequestsPerSecond: uptime > 0 ? totalRequests / uptime : 0.0
        };
        
        return metrics;
    }

    resource function get info() returns ServiceInfo {
        totalRequests += 1;
        
        ServiceInfo info = {
            serviceName: serviceName,
            version: "1.0.0",
            port: servicePort,
            debugMode: debugMode,
            maxBooksPerPage: maxBooksPerPage,
            startTime: serviceStartTime
        };
        
        return info;
    }

    resource function get requests/summary() returns RequestSummary {
        totalRequests += 1;
        
        time:Utc currentTime = time:utcNow();
        time:Seconds uptime = time:utcDiffSeconds(currentTime, serviceStartTime);
        
        RequestSummary summary = {
            totalRequests: totalRequests,
            requestsToday: totalRequests, // Simplified - in real implementation would track daily
            averageResponseTime: 0.15, // Mock value
            successRate: 98.5 // Mock value
        };
        
        return summary;
    }
}

function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }
    
    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }
    
    if bookRequest.isbn.trim().length() == 0 {
        return error("Book ISBN cannot be empty");
    }
    
    if bookRequest.price <= 0 {
        return error("Book price must be positive");
    }
    
    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }
    
    string bookId = uuid:createType4AsString();
    
    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };
    
    return validatedBook;
}
```
</code>

<code filename="types.bal">
```ballerina
public type Book record {|
    string id;
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type BookRequest record {|
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type BookCategory record {|
    string categoryId;
    string categoryName;
    string description;
|};

public type PaginatedBooks record {|
    Book[] books;
    int totalBooks;
    int currentPage;
    int totalPages;
|};

public type AdminStats record {|
    int totalBooks;
    int totalCategories;
    int totalRequests;
    decimal uptimeSeconds;
    string serviceName;
|};

// New types for Analytics service
public type HealthStatus record {|
    string status;
    string timestamp;
    decimal uptime;
    string version;
|};

public type SystemMetrics record {|
    int totalRequests;
    int totalBooks;
    int totalCategories;
    decimal uptime;
    float averageRequestsPerSecond;
|};

public type ServiceInfo record {|
    string serviceName;
    string version;
    int port;
    boolean debugMode;
    int maxBooksPerPage;
    string startTime;
|};

public type RequestSummary record {|
    int totalRequests;
    int requestsToday;
    float averageResponseTime;
    float successRate;
|};
```
</code>