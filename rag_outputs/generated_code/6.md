I'll add a new HTTP server to your existing bookstore implementation. Looking at your current code, you already have services running on port 8080 (`/bookstore` and `/admin`) and a placeholder for a new service on port 8081 (`/newapi`). I'll enhance this new server with proper functionality.

The new HTTP server will run on port 8081 and provide additional API endpoints for system information and health checks, complementing your existing bookstore and admin services.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

configurable int servicePort = 8080;
configurable int newServicePort = 8081;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;

int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

// New HTTP server on different port
service /api on new http:Listener(newServicePort) {
    
    resource function get health() returns json {
        time:Utc currentTime = time:utcNow();
        decimal uptime = time:utcDiffSeconds(currentTime, serviceStartTime);
        
        return {
            "status": "UP",
            "service": serviceName,
            "uptime_seconds": uptime,
            "timestamp": time:utcToString(currentTime)
        };
    }
    
    resource function get info() returns json {
        return {
            "service_name": serviceName,
            "version": "1.0.0",
            "total_requests": totalRequests,
            "total_books": bookStore.length(),
            "total_categories": bookCategories.length(),
            "debug_mode": debugMode
        };
    }
    
    resource function get stats() returns json {
        time:Utc currentTime = time:utcNow();
        decimal uptime = time:utcDiffSeconds(currentTime, serviceStartTime);
        
        return {
            "requests": {
                "total": totalRequests,
                "requests_per_second": uptime > 0 ? <float>totalRequests / <float>uptime : 0.0
            },
            "books": {
                "total_count": bookStore.length(),
                "categories_count": bookCategories.length()
            },
            "system": {
                "uptime_seconds": uptime,
                "start_time": time:utcToString(serviceStartTime)
            }
        };
    }
    
    resource function post echo(@http:Payload json message) returns json {
        totalRequests += 1;
        return {
            "echo": message,
            "timestamp": time:utcToString(time:utcNow()),
            "request_id": uuid:createType1AsString()
        };
    }
}

service /bookstore on new http:Listener(servicePort) {
    // Existing resources...
}

service /admin on new http:Listener(servicePort) {
    // Existing resources...
}

resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:BadRequest|http:InternalServerError {
    totalRequests += 1;

    Book|error validatedBook = validateAndFormatBook(bookRequest);
    if validatedBook is error {
        return http:BAD_REQUEST;
    }

    bookStore[validatedBook.id] = validatedBook;
    return http:CREATED;
}

resource function post categories(@http:Payload BookCategory category) returns http:Created|http:BadRequest {
    totalRequests += 1;

    if category.categoryName.trim().length() == 0 {
        return http:BAD_REQUEST;
    }

    bookCategories[category.categoryId] = category;
    return http:CREATED;
}
```
</code>