Looking at the existing code, I can see that the PUT /books/{bookId} endpoint is already using the `validateAndFormatBook` function to perform validation checks for empty titles, negative prices, etc. The current implementation correctly:

1. Calls `validateAndFormatBook(bookRequest)` to validate the incoming request
2. Returns `http:BAD_REQUEST` if validation fails
3. Uses the validated book data to create the updated book while preserving the original bookId

The validation logic in `validateAndFormatBook` already checks for:
- Empty titles (after trimming whitespace)
- Empty authors (after trimming whitespace) 
- Negative prices
- Negative quantities

The endpoint is already properly reusing this validation logic, so no modifications are needed. The current implementation ensures that all updates go through the same validation checks as new book creation.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;

int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

service /bookstore on new http:Listener(servicePort) {

    resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|http:NotFound|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        if !bookStore.hasKey(k = bookId) {
            return http:NOT_FOUND;
        }

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        Book updatedBook = {
            id: bookId,
            title: validatedBook.title,
            author: validatedBook.author,
            isbn: validatedBook.isbn,
            price: validatedBook.price,
            quantity: validatedBook.quantity
        };

        bookStore[bookId] = updatedBook;
        return updatedBook;
    }
}

function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    string bookId = uuid:createType1AsString();

    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}
```
</code>