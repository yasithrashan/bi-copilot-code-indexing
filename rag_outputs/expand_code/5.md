# Ballerina Code Expansion

**Query:** Standardize the error responses so they always return a JSON object with an error message (e.g., { \"error\": \"Book not found\" }) instead of just plain HTTP status codes.

---

Based on the user query and the relevant code chunks provided, I'll expand and organize the existing code to address the standardization of error responses. Here's the relevant code from the main.bal file:

## main.bal

Imports
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;
```

Configuration Variables
```ballerina
configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;
```

Module Level Variables
```ballerina
int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};
```

Services
```ballerina
service /bookstore on new http:Listener(servicePort) {
    // Resources will be expanded below
}
```

Resources
```ballerina
resource function get books(int page = 1, int 'limit = maxBooksPerPage) returns PaginatedBooks|ErrorResponse {
    totalRequests += 1;

    Book[] allBooks = bookStore.toArray();
    int totalCount = allBooks.length();
    int startIndex = (page - 1) * 'limit;
    int endIndex = startIndex + 'limit;

    if startIndex >= totalCount {
        PaginatedBooks emptyResult = {
            books: [],
            totalCount: totalCount,
            currentPage: page,
            totalPages: (totalCount + 'limit - 1) / 'limit
        };
        return emptyResult;
    }

    if endIndex > totalCount {
        endIndex = totalCount;
    }

    Book[] paginatedBooks = [];
    int index = startIndex;
    while index < endIndex {
        paginatedBooks.push(allBooks[index]);
        index += 1;
    }

    PaginatedBooks result = {
        books: paginatedBooks,
        totalCount: totalCount,
        currentPage: page,
        totalPages: (totalCount + 'limit - 1) / 'limit
    };

    return result;
}

resource function get books/[string bookId]() returns Book|ErrorResponse {
    totalRequests += 1;

    if bookStore.hasKey(k = bookId) {
        Book book = bookStore.get(k = bookId);
        return book;
    }
    return {error: "Book not found"};
}

resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|ErrorResponse {
    totalRequests += 1;

    Book|error validatedBook = validateAndFormatBook(bookRequest);
    if validatedBook is error {
        return {error: "Invalid book data: " + validatedBook.message()};
    }

    bookStore[validatedBook.id] = validatedBook;
    return http:CREATED;
}

resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|ErrorResponse {
    totalRequests += 1;

    if !bookStore.hasKey(k = bookId) {
        return {error: "Book not found"};
    }

    Book updatedBook = {
        id: bookId,
        title: bookRequest.title,
        author: bookRequest.author,
        isbn: bookRequest.isbn,
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    bookStore[bookId] = updatedBook;
    return updatedBook;
}

resource function delete books/[string bookId]() returns http:NoContent|ErrorResponse {
    totalRequests += 1;

    if !bookStore.hasKey(k = bookId) {
        return {error: "Book not found"};
    }

    _ = bookStore.remove(k = bookId);
    return http:NO_CONTENT;
}

resource function post books/search(@http:Payload BookSearchCriteria searchCriteria) returns Book[]|ErrorResponse {
    totalRequests += 1;

    Book[] allBooks = bookStore.toArray();
    Book[] filteredBooks = [];

    foreach Book book in allBooks {
        boolean matches = true;

        string? titleCriteria = searchCriteria.title;
        if titleCriteria is string {
            if !book.title.toLowerAscii().includes(titleCriteria.toLowerAscii()) {
                matches = false;
            }
        }

        string? authorCriteria = searchCriteria.author;
        if authorCriteria is string && matches {
            if !book.author.toLowerAscii().includes(authorCriteria.toLowerAscii()) {
                matches = false;
            }
        }

        string? isbnCriteria = searchCriteria.isbn;
        if isbnCriteria is string && matches {
            if !book.isbn.includes(isbnCriteria) {
                matches = false;
            }
        }

        decimal? minPriceCriteria = searchCriteria.minPrice;
        if minPriceCriteria is decimal && matches {
            if book.price < minPriceCriteria {
                matches = false;
            }
        }

        decimal? maxPriceCriteria = searchCriteria.maxPrice;
        if maxPriceCriteria is decimal && matches {
            if book.price > maxPriceCriteria {
                matches = false;
            }
        }

        if matches {
            filteredBooks.push(book);
        }
    }

    return filteredBooks;
}
```

Matching Resources
```ballerina
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    string bookId = uuid:createType1AsString();

    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}
```

## types.bal

```ballerina
public type Book record {|
    string id;
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type BookRequest record {|
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type ErrorResponse record {|
    string error;
|};

public type PaginatedBooks record {|
    Book[] books;
    int totalCount;
    int currentPage;
    int totalPages;
|};

public type BookSearchCriteria record {|
    string? title;
    string? author;
    string? isbn;
    decimal? minPrice;
    decimal? maxPrice;
|};
```

---

*Code expansion generated from 8 relevant chunks across 1 files*
