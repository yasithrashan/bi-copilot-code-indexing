=== QUERY ID 2 ===
Modify the PUT /books/{bookId} endpoint to reuse the validation logic (validateAndFormatBook) so updates also check for empty titles, negative prices, etc.

=== API DOC USED ===
api_docs/2.json

=== EXTRACTED CODE USED ===
agentic_outputs/expand_code/2.md

=== TOKEN USAGE ===
{
  "langLibs": 13563,
  "apiDocs": 458,
  "balMdContent": 1423,
  "extractedCode": 467,
  "userQuery": 44,
  "systemPrompt": 16719,
  "generatedCode": 587,
  "totalInput": 17244,
  "toolCalls": 14
}

=== GENERATED CODE RESPONSE ===
Now I can see the issue! The current PUT endpoint doesn't use the `validateAndFormatBook` function and lacks validation. The POST endpoint likely uses this validation function, but the PUT endpoint directly creates the book without validation. Let me modify the PUT endpoint to reuse the validation logic:

<code filename="main.bal">
```ballerina
// Modified PUT endpoint to reuse validation logic
resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|http:NotFound|http:BadRequest|http:InternalServerError {\n    totalRequests += 1;\n\n    if !bookStore.hasKey(bookId) {\n        return http:NOT_FOUND;\n    }\n\n    // Reuse the validation logic\n    Book|error validationResult = validateAndFormatBook(bookRequest);\n    if validationResult is error {\n        http:BadRequest badRequest = {\n            body: {\n                message: validationResult.message()\n            }\n        };\n        return badRequest;\n    }\n\n    // Use the validated book data but preserve the original bookId\n    Book validatedBook = validationResult;\n    Book updatedBook = {\n        id: bookId, // Keep the original bookId instead of the generated one\n        title: validatedBook.title,\n        author: validatedBook.author,\n        isbn: validatedBook.isbn,\n        price: validatedBook.price,\n        quantity: validatedBook.quantity\n    };\n\n    bookStore[bookId] = updatedBook;\n    return updatedBook;\n}
```
</code>

The key changes I made to the PUT endpoint:

1. **Added validation**: Now calls `validateAndFormatBook(bookRequest)` to perform all the validation checks (empty titles, negative prices, etc.)

2. **Proper error handling**: If validation fails, it returns a `http:BadRequest` with the error message from the validation function

3. **Preserved bookId**: The validation function generates a new UUID, but for updates, we want to keep the original bookId from the path parameter, so I extract the validated data but use the original bookId

4. **Consistent data formatting**: Now the PUT endpoint will also trim whitespace from title, author, and ISBN fields, just like the POST endpoint

This ensures that both POST and PUT operations use the same validation logic, making the API consistent and preventing invalid data from being stored during updates.

