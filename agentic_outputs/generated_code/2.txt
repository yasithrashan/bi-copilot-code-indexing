=== QUERY ID 2 ===
Modify the PUT /books/{bookId} endpoint to reuse the validation logic (validateAndFormatBook) so updates also check for empty titles, negative prices, etc.

=== API DOC USED ===
api_docs/2.json

=== EXTRACTED CODE USED ===
agentic_outputs/expand_code/2.md

=== GENERATED CODE RESPONSE ===
Now I can see the current implementation. The PUT endpoint is currently not using the `validateAndFormatBook` function and is directly creating the book without validation. Let me modify it to reuse the validation logic.

<code filename="main.bal">
```ballerina
// Utility function to validate and format book data
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    string bookId = uuid:createType1AsString();

    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}

// Updated validateAndFormatBookForUpdate function for updates
function validateAndFormatBookForUpdate(string bookId, BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}

// Modified PUT endpoint with validation
resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|http:NotFound|http:BadRequest|http:InternalServerError {
    totalRequests += 1;

    if !bookStore.hasKey(k = bookId) {
        return http:NOT_FOUND;
    }

    do {
        Book validatedBook = check validateAndFormatBookForUpdate(bookId, bookRequest);
        bookStore[bookId] = validatedBook;
        return validatedBook;
    } on fail error e {
        return <http:BadRequest>{ body: { message: e.message() } };
    }
}
```
</code>

The key changes I made to improve the PUT endpoint:

1. **Added a new validation function**: `validateAndFormatBookForUpdate` that specifically handles updates by accepting the existing `bookId` rather than generating a new one.

2. **Implemented proper validation**: The PUT endpoint now validates:
   - Empty titles (after trimming whitespace)
   - Empty authors (after trimming whitespace) 
   - Negative prices
   - Negative quantities

3. **Added error handling**: Used a `do-on fail` block to catch validation errors and return appropriate HTTP 400 Bad Request responses with error messages.

4. **Data sanitization**: The validation function trims whitespace from title, author, and ISBN fields before storing.

5. **Consistent behavior**: Now both POST and PUT endpoints use similar validation logic, ensuring data consistency across create and update operations.

The endpoint now properly validates all book data before updating, preventing invalid books from being stored and providing clear error messages to clients when validation fails.

