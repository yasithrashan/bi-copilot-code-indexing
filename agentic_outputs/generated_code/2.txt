=== QUERY ID 2 ===
Modify the PUT /books/{bookId} endpoint to reuse the validation logic (validateAndFormatBook) so updates also check for empty titles, negative prices, etc.

=== API DOC USED ===
api_docs/2.json

=== EXTRACTED CODE USED ===
agentic_outputs/expand_code/2.md

=== GENERATED CODE RESPONSE ===
Now I can see the current implementation. The PUT endpoint is not using the validation logic, while the `validateAndFormatBook` function contains comprehensive validation for empty titles, negative prices, etc. I need to modify the PUT endpoint to use this validation function, but also need to adapt it slightly since the validation function generates a new ID, but for updates we want to keep the existing ID.

Let me modify the code to reuse the validation logic:

<code filename="main.bal">
```ballerina
// Utility function to validate and format book data
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    string bookId = uuid:createType1AsString();

    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}

// Updated PUT endpoint implementation that reuses validation logic
resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|http:NotFound|http:BadRequest|http:InternalServerError {
    totalRequests += 1;

    if !bookStore.hasKey(k = bookId) {
        return http:NOT_FOUND;
    }

    // Use the validation logic from validateAndFormatBook
    Book|error validationResult = validateAndFormatBook(bookRequest);
    if validationResult is error {
        return <http:BadRequest>{
            body: {
                message: validationResult.message()
            }
        };
    }

    // Create the updated book with the existing bookId (not the generated one)
    Book updatedBook = {
        id: bookId,  // Keep the existing ID
        title: validationResult.title,
        author: validationResult.author,
        isbn: validationResult.isbn,
        price: validationResult.price,
        quantity: validationResult.quantity
    };

    bookStore[bookId] = updatedBook;
    return updatedBook;
}
```
</code>

The key changes I made to the PUT endpoint:

1. **Added validation**: The endpoint now calls `validateAndFormatBook(bookRequest)` to validate the input data
2. **Error handling**: If validation fails, it returns a `400 Bad Request` with the error message
3. **Preserve existing ID**: Since this is an update operation, I preserve the existing `bookId` from the path parameter instead of using the generated ID from the validation function
4. **Reuse validated data**: The updated book uses the trimmed and validated data from the validation result

Now the PUT endpoint will check for:
- Empty titles (after trimming whitespace)
- Empty authors (after trimming whitespace)  
- Negative prices
- Negative quantities

This ensures consistency between the POST (create) and PUT (update) operations, both using the same validation logic while maintaining the appropriate behavior for each operation (new ID for POST, existing ID for PUT).

