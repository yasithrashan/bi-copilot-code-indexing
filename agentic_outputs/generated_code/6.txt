=== QUERY ID 6 ===
Add a new HTTP server to the current implementation.

=== API DOC USED ===
api_docs/6.json

=== EXTRACTED CODE USED ===
agentic_outputs/expand_code/6.md

=== TOKEN USAGE ===
{
  "langLibs": 13563,
  "apiDocs": 876,
  "balMdContent": 1423,
  "extractedCode": 214,
  "userQuery": 17,
  "systemPrompt": 17137,
  "generatedCode": 1166,
  "totalInput": 17382,
  "toolCalls": 14
}

=== GENERATED CODE RESPONSE ===
Based on the extracted code and project summary, I can see that the current implementation has two HTTP services (`/bookstore` and `/admin`) running on the same HTTP listener on port 8080. I'll add a new HTTP server with a separate listener on a different port.

Here's the code to add a new HTTP server:

<code filename="main.bal">
```ballerina
// Add new configurable for the new server port
configurable int analyticsServerPort = 8081;
configurable string analyticsServerName = "Analytics Server";

// New HTTP service for analytics and monitoring
service /analytics on new http:Listener(analyticsServerPort) {
    
    # Health check endpoint for analytics server
    # + return - Health status of analytics server
    resource function get health() returns map<string> {
        return {
            "status": "UP",
            "server": analyticsServerName,
            "port": analyticsServerPort.toString(),
            "timestamp": time:utcNow().toString()
        };
    }
    
    # Get detailed analytics about book operations
    # + return - Analytics data about book operations
    resource function get metrics() returns map<anydata> {
        int totalBooksCount = bookStore.length();
        string[] topCategories = bookCategories.keys();
        
        return {
            "serverName": analyticsServerName,
            "totalRequests": totalRequests,
            "totalBooks": totalBooksCount,
            "totalCategories": bookCategories.length(),
            "uptime": calculateUptime(),
            "averageBooksPerCategory": totalBooksCount > 0 && bookCategories.length() > 0 
                ? totalBooksCount / bookCategories.length() : 0,
            "categories": topCategories
        };
    }
    
    # Get server performance metrics
    # + return - Performance metrics of all servers
    resource function get performance() returns map<anydata> {
        return {
            "mainServer": {
                "port": servicePort,
                "serviceName": serviceName,
                "totalRequests": totalRequests,
                "debugMode": debugMode
            },
            "analyticsServer": {
                "port": analyticsServerPort,
                "serviceName": analyticsServerName,
                "uptime": calculateUptime()
            },
            "systemMetrics": {
                "memoryUsage": "N/A", // Placeholder for future implementation
                "cpuUsage": "N/A"     // Placeholder for future implementation
            }
        };
    }
    
    # Reset analytics counters (useful for testing)
    # + return - Success message
    resource function post reset() returns map<string> {
        // Reset total requests counter
        totalRequests = 0;
        
        return {
            "message": "Analytics counters reset successfully",
            "resetTime": time:utcNow().toString(),
            "server": analyticsServerName
        };
    }
}

# Helper function to calculate server uptime
# + return - Uptime in a readable format
function calculateUptime() returns string {
    time:Utc currentTime = time:utcNow();
    decimal uptimeSeconds = time:utcDiffSeconds(currentTime, serviceStartTime);
    
    int hours = <int>(uptimeSeconds / 3600);
    int minutes = <int>((uptimeSeconds % 3600) / 60);
    int seconds = <int>(uptimeSeconds % 60);
    
    return string `${hours}h ${minutes}m ${seconds}s`;
}
```
</code>

This implementation adds:

1. **New Configurable Variables**: 
   - `analyticsServerPort` (default: 8081) - Port for the new analytics server
   - `analyticsServerName` (default: "Analytics Server") - Name identifier for the analytics server

2. **New HTTP Service**: `/analytics` running on a separate HTTP listener on port 8081

3. **New Endpoints**:
   - `GET /analytics/health` - Health check for the analytics server
   - `GET /analytics/metrics` - Detailed analytics about book operations
   - `GET /analytics/performance` - Performance metrics for all servers
   - `POST /analytics/reset` - Reset analytics counters

4. **Helper Function**: `calculateUptime()` - Calculates and formats server uptime

The new server runs independently on port 8081 and provides analytics and monitoring capabilities separate from the main bookstore API. This follows the microservices pattern where different concerns (main API vs analytics) are separated into different services.

You can access the new server at:
- Health: `http://localhost:8081/analytics/health`
- Metrics: `http://localhost:8081/analytics/metrics` 
- Performance: `http://localhost:8081/analytics/performance`
- Reset: `POST http://localhost:8081/analytics/reset`

