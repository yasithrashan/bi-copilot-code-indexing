=== QUERY ID 6 ===
Add a new HTTP server to the current implementation.

=== API DOC USED ===
api_docs/6.json

=== EXTRACTED CODE USED ===
agentic_outputs/expand_code/6.md

=== GENERATED CODE RESPONSE ===
Based on the extracted code and the project summary, I can see that the current implementation has two HTTP services (`/bookstore` and `/admin`) running on the same listener at port 8080. To add a new HTTP server, I'll provide you with a few options depending on your needs.

Here's how you can add a new HTTP server:

<code filename="main.bal">
```ballerina
// Add a new configurable port for the new server
configurable int newServerPort = 8081;
configurable string newServiceName = "Analytics API";

// Option 1: Add a new service on the same listener (same port)
service /analytics on new http:Listener(servicePort) {
    
    // Health check endpoint
    resource function get health() returns map<string> {
        return {
            "status": "UP",
            "service": newServiceName,
            "port": servicePort.toString(),
            "timestamp": time:utcNow()[0].toString()
        };
    }
    
    // Example analytics endpoint
    resource function get metrics() returns json|http:InternalServerError {
        do {
            json metrics = {
                "totalRequests": totalRequests,
                "totalBooks": bookStore.length(),
                "totalCategories": bookCategories.length(),
                "uptime": time:utcDiffSeconds(time:utcNow()[0], serviceStartTime)
            };
            return metrics;
        } on fail var e {
            return http:INTERNAL_SERVER_ERROR;
        }
    }
    
    // Example data export endpoint
    resource function get 'export/books() returns Book[]|http:InternalServerError {
        do {
            return bookStore.toArray();
        } on fail var e {
            return http:INTERNAL_SERVER_ERROR;
        }
    }
}

// Option 2: Add a completely new HTTP server on a different port
service /reporting on new http:Listener(newServerPort) {
    
    // Health check for the new server
    resource function get health() returns map<string> {
        return {
            "status": "UP",
            "service": newServiceName,
            "port": newServerPort.toString(),
            "timestamp": time:utcNow()[0].toString()
        };
    }
    
    // Generate reports endpoint
    resource function get reports/daily() returns json|http:InternalServerError {
        do {
            json report = {
                "reportType": "daily",
                "generatedAt": time:utcNow()[0].toString(),
                "totalBooks": bookStore.length(),
                "totalRequests": totalRequests,
                "booksByCategory": self.getBooksByCategory()
            };
            return report;
        } on fail var e {
            return http:INTERNAL_SERVER_ERROR;
        }
    }
    
    // Helper function to get books grouped by category
    private function getBooksByCategory() returns map<int> {
        map<int> categoryCount = {};
        // Logic to count books by category would go here
        // This is a placeholder implementation
        return categoryCount;
    }
    
    // Download report as file
    resource function get reports/download/[string reportType]() returns http:Response|http:BadRequest|http:InternalServerError {
        if reportType != "daily" && reportType != "weekly" && reportType != "monthly" {
            return http:BAD_REQUEST;
        }
        
        do {
            http:Response response = new;
            json reportData = {
                "reportType": reportType,
                "data": bookStore.toArray(),
                "generatedAt": time:utcNow()[0].toString()
            };
            
            response.setJsonPayload(reportData);
            response.setHeader("Content-Disposition", string `attachment; filename=${reportType}_report.json`);
            response.setHeader("Content-Type", "application/json");
            
            return response;
        } on fail var e {
            return http:INTERNAL_SERVER_ERROR;
        }
    }
}
```
</code>

The code above shows two approaches:

1. **Option 1 - Same Port Different Path** (`/analytics`): Adds a new service on the same HTTP listener (port 8080) with a different base path. This is useful when you want related services on the same port.

2. **Option 2 - Different Port** (`/reporting`): Creates a completely separate HTTP server on a different port (8081). This is useful when you want to separate concerns or have different security/access requirements.

**Key Features Added:**

- **New configurable variables** for the new server port and service name
- **Health endpoints** for both new services
- **Analytics service** with metrics and data export capabilities
- **Reporting service** with report generation and download functionality
- **Proper error handling** following the existing pattern
- **Integration with existing data** (bookStore, bookCategories, totalRequests)

**Benefits:**

- **Modular design**: Each service has a specific purpose
- **Scalable**: Easy to add more endpoints to each service
- **Consistent**: Follows the same patterns as existing services
- **Configurable**: Port and service names can be configured

You can choose either option or implement both depending on your specific requirements. The new servers will run alongside your existing bookstore and admin services.

