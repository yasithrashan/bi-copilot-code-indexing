=== QUERY ID 5 ===
Standardize the error responses so they always return a JSON object with an error message (e.g., { \"error\": \"Book not found\" }) instead of just plain HTTP status codes.

=== API DOC USED ===
api_docs/5.json

=== EXTRACTED CODE USED ===
agentic_outputs/expand_code/5.md

=== GENERATED CODE RESPONSE ===
Now I can see the current implementation and the ErrorResponse type that's already defined. I need to update all the endpoints to return proper JSON error responses using the ErrorResponse type instead of plain HTTP status codes. Let me provide the updated code:

<code filename="types.bal">
```ballerina
// Error response type
public type ErrorResponse record {|
    string error;
|};
```
</code>

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

// Configurable variables
configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;

// Module level variables
int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

// Utility function to validate and format book data
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    if bookRequest.isbn.trim().length() == 0 {
        return error("ISBN cannot be empty");
    }

    // Check if ISBN already exists
    foreach Book book in bookStore {
        if book.isbn == bookRequest.isbn {
            return error("Book with this ISBN already exists");
        }
    }

    Book book = {
        id: uuid:createType1AsString(),
        title: bookRequest.title,
        author: bookRequest.author,
        isbn: bookRequest.isbn,
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return book;
}

// Bookstore service
service /bookstore on new http:Listener(servicePort) {

    // Get all books with pagination
    resource function get books(int page = 1, int 'limit = maxBooksPerPage) returns PaginatedBooks|ErrorResponse {
        totalRequests += 1;

        if page < 1 {
            return {error: "Page number must be greater than 0"};
        }

        if 'limit < 1 || 'limit > maxBooksPerPage {
            return {error: string `Limit must be between 1 and ${maxBooksPerPage}`};
        }

        Book[] books = bookStore.toArray();
        int totalCount = books.length();
        int startIndex = (page - 1) * 'limit;

        if startIndex >= totalCount {
            return {
                books: [],
                totalCount: totalCount,
                currentPage: page,
                totalPages: (totalCount + 'limit - 1) / 'limit
            };
        }

        int endIndex = startIndex + 'limit;
        if endIndex > totalCount {
            endIndex = totalCount;
        }

        Book[] paginatedBooks = books.slice(startIndex, endIndex);

        return {
            books: paginatedBooks,
            totalCount: totalCount,
            currentPage: page,
            totalPages: (totalCount + 'limit - 1) / 'limit
        };
    }

    // Get a specific book by ID
    resource function get books/[string bookId]() returns Book|ErrorResponse {
        totalRequests += 1;

        if bookStore.hasKey(k = bookId) {
            Book book = bookStore.get(k = bookId);
            return book;
        }
        return {error: "Book not found"};
    }

    // Add a new book
    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|ErrorResponse {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return {error: validatedBook.message()};
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }

    // Update an existing book
    resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|ErrorResponse {
        totalRequests += 1;

        if !bookStore.hasKey(k = bookId) {
            return {error: "Book not found"};
        }

        // Create a temporary book request validation (excluding ISBN uniqueness check for updates)
        if bookRequest.title.trim().length() == 0 {
            return {error: "Book title cannot be empty"};
        }

        if bookRequest.author.trim().length() == 0 {
            return {error: "Book author cannot be empty"};
        }

        if bookRequest.price < 0.0d {
            return {error: "Book price cannot be negative"};
        }

        if bookRequest.quantity < 0 {
            return {error: "Book quantity cannot be negative"};
        }

        if bookRequest.isbn.trim().length() == 0 {
            return {error: "ISBN cannot be empty"};
        }

        // Check if ISBN already exists for other books
        foreach Book book in bookStore {
            if book.isbn == bookRequest.isbn && book.id != bookId {
                return {error: "Book with this ISBN already exists"};
            }
        }

        Book updatedBook = {
            id: bookId,
            title: bookRequest.title,
            author: bookRequest.author,
            isbn: bookRequest.isbn,
            price: bookRequest.price,
            quantity: bookRequest.quantity
        };

        bookStore[bookId] = updatedBook;
        return updatedBook;
    }

    // Delete a book
    resource function delete books/[string bookId]() returns http:NoContent|ErrorResponse {
        totalRequests += 1;

        if !bookStore.hasKey(k = bookId) {
            return {error: "Book not found"};
        }

        _ = bookStore.remove(k = bookId);
        return http:NO_CONTENT;
    }

    // Search books based on criteria
    resource function post books/search(@http:Payload BookSearchCriteria searchCriteria) returns Book[]|ErrorResponse {
        totalRequests += 1;

        Book[] books = bookStore.toArray();
        Book[] filteredBooks = [];

        foreach Book book in books {
            boolean matches = true;

            if searchCriteria.title is string {
                string searchTitle = searchCriteria.title ?: "";
                if !book.title.toLowerAscii().includes(searchTitle.toLowerAscii()) {
                    matches = false;
                }
            }

            if matches && searchCriteria.author is string {
                string searchAuthor = searchCriteria.author ?: "";
                if !book.author.toLowerAscii().includes(searchAuthor.toLowerAscii()) {
                    matches = false;
                }
            }

            if matches && searchCriteria.isbn is string {
                string searchIsbn = searchCriteria.isbn ?: "";
                if !book.isbn.toLowerAscii().includes(searchIsbn.toLowerAscii()) {
                    matches = false;
                }
            }

            if matches && searchCriteria.minPrice is decimal {
                decimal minPrice = searchCriteria.minPrice ?: 0.0d;
                if book.price < minPrice {
                    matches = false;
                }
            }

            if matches && searchCriteria.maxPrice is decimal {
                decimal maxPrice = searchCriteria.maxPrice ?: 0.0d;
                if book.price > maxPrice {
                    matches = false;
                }
            }

            if matches {
                filteredBooks.push(book);
            }
        }

        return filteredBooks;
    }

    // Health check endpoint
    resource function get health() returns map<string> {
        totalRequests += 1;
        return {
            "status": "UP",
            "service": serviceName,
            "timestamp": time:utcToString(time:utcNow())
        };
    }
}

// Admin service
service /admin on new http:Listener(servicePort) {

    // Get service statistics
    resource function get stats() returns ServiceStats {
        totalRequests += 1;
        return {
            totalRequests: totalRequests,
            totalBooks: bookStore.length(),
            serviceStartTime: time:utcToString(serviceStartTime),
            serviceName: serviceName,
            debugMode: debugMode
        };
    }

    // Create a new book category
    resource function post categories(@http:Payload BookCategory category) returns http:Created|ErrorResponse {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            return {error: "Category name cannot be empty"};
        }

        if category.categoryId.trim().length() == 0 {
            return {error: "Category ID cannot be empty"};
        }

        if bookCategories.hasKey(k = category.categoryId) {
            return {error: "Category with this ID already exists"};
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }

    // Get all book categories
    resource function get categories() returns BookCategory[] {
        totalRequests += 1;
        return bookCategories.toArray();
    }
}
```
</code>

## Summary of Changes

I've standardized all error responses across the bookstore API to consistently return JSON objects with an `error` field instead of plain HTTP status codes. Here are the key changes:

### 1. **Updated ErrorResponse Type**
- Changed the field name from `message` to `error` to match your requested format
- This ensures all error responses follow the `{"error": "error message"}` structure

### 2. **Standardized Error Responses in All Endpoints**

**Bookstore Service:**
- **GET /books**: Added validation for page and limit parameters with proper error messages
- **GET /books/{bookId}**: Returns `{error: "Book not found"}` instead of `http:NOT_FOUND`
- **POST /books**: Returns `{error: validatedBook.message()}` instead of `http:BAD_REQUEST`
- **PUT /books/{bookId}**: Returns specific error messages for validation failures and "Book not found"
- **DELETE /books/{bookId}**: Returns `{error: "Book not found"}` instead of `http:NOT_FOUND`
- **POST /books/search**: Now returns `ErrorResponse` for any potential errors

**Admin Service:**
- **POST /categories**: Returns proper error messages for validation failures instead of `http:BAD_REQUEST`

### 3. **Enhanced Error Messages**
- All error messages are now descriptive and user-friendly
- Validation errors provide specific information about what went wrong
- Consistent error format across all endpoints

### 4. **Benefits of This Standardization**
- **Consistent API Response Format**: All errors now follow the same JSON structure
- **Better Client Integration**: Clients can reliably parse error responses
- **Improved User Experience**: Clear, descriptive error messages
- **Easier Debugging**: Standardized error handling makes troubleshooting simpler

Now all your API endpoints will return consistent JSON error responses in the format `{"error": "descriptive error message"}`, making your API more predictable and easier to work with for client applications.

