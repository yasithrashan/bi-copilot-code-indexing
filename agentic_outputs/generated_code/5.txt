=== QUERY ID 5 ===
Standardize the error responses so they always return a JSON object with an error message (e.g., { \"error\": \"Book not found\" }) instead of just plain HTTP status codes.

=== API DOC USED ===
api_docs/5.json

=== EXTRACTED CODE USED ===
agentic_outputs/expand_code/5.md

=== TOKEN USAGE ===
{
  "langLibs": 13563,
  "apiDocs": 5570,
  "balMdContent": 1423,
  "extractedCode": 460,
  "userQuery": 48,
  "systemPrompt": 21831,
  "generatedCode": 2517,
  "totalInput": 22353,
  "toolCalls": 14
}

=== GENERATED CODE RESPONSE ===
Now I can see the current implementation. The API currently returns plain HTTP status codes like `http:NOT_FOUND`, `http:BAD_REQUEST`, etc., and there's an `ErrorResponse` type defined but not being used. I'll standardize all error responses to return JSON objects with error messages.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

// Configurable variables
configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;

// Module level variables
int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

// Utility function to validate and format book data
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    // Generate unique ID and create book
    string bookId = uuid:createType1AsString();
    
    Book book = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return book;
}

service /bookstore on new http:Listener(servicePort) {

    // Get all books with pagination
    resource function get books(int page = 1, int 'limit = maxBooksPerPage) returns PaginatedBooks|ErrorResponse {
        totalRequests += 1;

        if page < 1 {
            return {message: "Page number must be greater than 0"};
        }

        if 'limit < 1 || 'limit > maxBooksPerPage {
            return {message: "Limit must be between 1 and " + maxBooksPerPage.toString()};
        }

        Book[] allBooks = bookStore.toArray();
        int totalCount = allBooks.length();
        int totalPages = totalCount / 'limit + (totalCount % 'limit == 0 ? 0 : 1);

        if totalPages == 0 {
            totalPages = 1;
        }

        if page > totalPages {
            return {message: "Page number exceeds total pages"};
        }

        int startIndex = (page - 1) * 'limit;
        int endIndex = startIndex + 'limit;
        if endIndex > totalCount {
            endIndex = totalCount;
        }

        Book[] paginatedBooks = [];
        int index = 0;
        foreach Book book in allBooks {
            if index >= startIndex && index < endIndex {
                paginatedBooks.push(book);
            }
            index += 1;
        }

        PaginatedBooks result = {
            books: paginatedBooks,
            totalCount: totalCount,
            currentPage: page,
            totalPages: totalPages
        };

        return result;
    }

    // Get a specific book by ID
    resource function get books/[string bookId]() returns Book|ErrorResponse {
        totalRequests += 1;

        if bookStore.hasKey(k = bookId) {
            Book book = bookStore.get(k = bookId);
            return book;
        }
        return {message: "Book not found"};
    }

    // Add a new book
    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|ErrorResponse {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return {message: validatedBook.message()};
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }

    // Update an existing book
    resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|ErrorResponse {
        totalRequests += 1;

        if !bookStore.hasKey(k = bookId) {
            return {message: "Book not found"};
        }

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return {message: validatedBook.message()};
        }

        // Keep the original ID
        Book updatedBook = {
            id: bookId,
            title: validatedBook.title,
            author: validatedBook.author,
            isbn: validatedBook.isbn,
            price: validatedBook.price,
            quantity: validatedBook.quantity
        };

        bookStore[bookId] = updatedBook;
        return updatedBook;
    }

    // Delete a book
    resource function delete books/[string bookId]() returns http:NoContent|ErrorResponse {
        totalRequests += 1;

        if !bookStore.hasKey(k = bookId) {
            return {message: "Book not found"};
        }

        _ = bookStore.remove(k = bookId);
        return http:NO_CONTENT;
    }

    // Search books based on criteria
    resource function post books/search(@http:Payload BookSearchCriteria searchCriteria) returns Book[]|ErrorResponse {
        totalRequests += 1;

        Book[] allBooks = bookStore.toArray();
        Book[] filteredBooks = [];

        foreach Book book in allBooks {
            boolean matches = true;

            // Check title filter
            if searchCriteria.title is string {
                string titleFilter = searchCriteria.title ?: "";
                if !book.title.toLowerAscii().includes(titleFilter.toLowerAscii()) {
                    matches = false;
                }
            }

            // Check author filter
            if searchCriteria.author is string {
                string authorFilter = searchCriteria.author ?: "";
                if !book.author.toLowerAscii().includes(authorFilter.toLowerAscii()) {
                    matches = false;
                }
            }

            // Check ISBN filter
            if searchCriteria.isbn is string {
                string isbnFilter = searchCriteria.isbn ?: "";
                if !book.isbn.includes(isbnFilter) {
                    matches = false;
                }
            }

            // Check price range
            if searchCriteria.minPrice is decimal {
                decimal minPrice = searchCriteria.minPrice ?: 0.0d;
                if book.price < minPrice {
                    matches = false;
                }
            }

            if searchCriteria.maxPrice is decimal {
                decimal maxPrice = searchCriteria.maxPrice ?: 0.0d;
                if book.price > maxPrice {
                    matches = false;
                }
            }

            if matches {
                filteredBooks.push(book);
            }
        }

        return filteredBooks;
    }

    // Health check endpoint
    resource function get health() returns map<string> {
        totalRequests += 1;

        map<string> healthStatus = {
            "status": "healthy",
            "service": serviceName,
            "timestamp": time:utcToString(time:utcNow())
        };

        return healthStatus;
    }
}

service /admin on new http:Listener(servicePort) {

    // Get service statistics
    resource function get stats() returns ServiceStats {
        totalRequests += 1;

        ServiceStats stats = {
            totalRequests: totalRequests,
            totalBooks: bookStore.length(),
            serviceStartTime: time:utcToString(serviceStartTime),
            serviceName: serviceName,
            debugMode: debugMode
        };

        return stats;
    }

    // Add a new book category
    resource function post categories(@http:Payload BookCategory category) returns http:Created|ErrorResponse {
        totalRequests += 1;

        if category.categoryId.trim().length() == 0 {
            return {message: "Category ID cannot be empty"};
        }

        if category.categoryName.trim().length() == 0 {
            return {message: "Category name cannot be empty"};
        }

        if bookCategories.hasKey(k = category.categoryId) {
            return {message: "Category with this ID already exists"};
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }

    // Get all book categories
    resource function get categories() returns BookCategory[] {
        totalRequests += 1;

        return bookCategories.toArray();
    }
}
```
</code>

The key changes I made to standardize error responses:

1. **Updated return types**: Changed all error return types from plain HTTP status codes (like `http:NotFound`, `http:BadRequest`, `http:InternalServerError`) to `ErrorResponse`

2. **Consistent error format**: All errors now return JSON objects with the `ErrorResponse` type structure: `{message: "error description"}`

3. **Specific error messages**: Replaced generic HTTP status codes with descriptive error messages:
   - "Book not found" instead of `http:NOT_FOUND`
   - "Book title cannot be empty" instead of `http:BAD_REQUEST`
   - "Page number must be greater than 0" for pagination errors
   - "Category with this ID already exists" for duplicate categories

4. **Error message extraction**: Used the `error.message()` function to extract meaningful error messages from validation errors

5. **Added validation errors**: Enhanced validation with specific error messages for invalid input parameters like page numbers and limits

Now all error responses follow a consistent JSON format with descriptive messages, making the API more user-friendly and easier to debug. The `ErrorResponse` type that was already defined in `types.bal` is now being properly utilized throughout the application.

