## Explanation

Based on the existing code context, I can see there are already two HTTP services running on the same port (8080): `/bookstore` and `/admin`. To add a new HTTP server, I'll create a third service that runs on a different port to avoid conflicts.

The new HTTP server will:
1. Run on port 8082 (different from the existing port 8080)
2. Include a basic service endpoint `/api` 
3. Provide some sample resources like a health check and a general information endpoint
4. Follow the same patterns as the existing services with proper error handling and request counting
5. Integrate with the existing module-level variables for consistency

The implementation will use the `ballerina/http` module's `http:Listener` to create a new server instance and define a service with sample resources that demonstrate basic HTTP operations.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

configurable int servicePort = 8080;
configurable int newServicePort = 8082;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;

int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

// Existing HTTP service for bookstore
service /bookstore on new http:Listener(servicePort) {
    // Existing resources would be here
    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }
}

// Existing admin service
service /admin on new http:Listener(servicePort) {
    // Existing resources would be here
    resource function post categories(@http:Payload BookCategory category) returns http:Created|http:BadRequest {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            return http:BAD_REQUEST;
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }
}

// New HTTP server
service /api on new http:Listener(newServicePort) {
    
    resource function get health() returns json {
        totalRequests += 1;
        
        return {
            "status": "UP",
            "timestamp": time:utcNow().toString(),
            "service": "API Service",
            "port": newServicePort
        };
    }
    
    resource function get info() returns json {
        totalRequests += 1;
        
        time:Utc currentTime = time:utcNow();
        
        return {
            "serviceName": "New API Service",
            "version": "1.0.0",
            "startTime": serviceStartTime.toString(),
            "currentTime": currentTime.toString(),
            "totalRequests": totalRequests,
            "totalBooks": bookStore.length(),
            "totalCategories": bookCategories.length(),
            "port": newServicePort
        };
    }
    
    resource function get books() returns json|http:InternalServerError {
        totalRequests += 1;
        
        json[] bookList = [];
        foreach Book book in bookStore {
            json bookJson = book.toJson();
            bookList.push(bookJson);
        }
        
        return {
            "books": bookList,
            "count": bookList.length()
        };
    }
    
    resource function post echo(@http:Payload json payload) returns json|http:BadRequest {
        totalRequests += 1;
        
        if payload is () {
            return http:BAD_REQUEST;
        }
        
        return {
            "echo": payload,
            "timestamp": time:utcNow().toString(),
            "requestId": uuid:createType1AsString()
        };
    }
}

// Assuming these types and functions exist based on the existing code context
type Book record {
    string id;
    string title;
    string author;
    // Other book fields would be defined here
};

type BookRequest record {
    string title;
    string author;
    // Other book request fields would be defined here
};

type BookCategory record {
    string categoryId;
    string categoryName;
    // Other category fields would be defined here
};

// Placeholder function - would contain actual validation logic
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    // Validation logic would be implemented here
    Book book = {
        id: uuid:createType1AsString(),
        title: bookRequest.title,
        author: bookRequest.author
    };
    return book;
}
```
</code>