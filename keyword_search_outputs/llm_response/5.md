I'll help you standardize the error responses in your bookstore API to always return JSON objects with error messages instead of plain HTTP status codes.

## Explanation

Looking at your existing code, I can see that you have a bookstore API with various resource functions that currently return different types of HTTP responses. The goal is to standardize all error responses to return JSON objects with a consistent structure like `{ "error": "Book not found" }`.

Here's what I need to modify:

1. **Update the `ErrorResponse` type** in `types.bal` to ensure it has the correct structure
2. **Modify all resource functions** in `main.bal` to return `ErrorResponse` records instead of HTTP status code responses
3. **Add proper HTTP status annotations** to ensure the correct HTTP status codes are still returned along with the JSON error messages
4. **Update return types** of all resource functions to include `ErrorResponse`

The key changes will be:
- Replace `http:NotFound`, `http:BadRequest`, etc. with `ErrorResponse` records
- Add `@http:Payload` annotations where needed for proper response formatting
- Ensure all error conditions return consistent JSON structure
- Maintain the same HTTP status codes but with JSON payloads

Let me implement these changes:

<code filename="types.bal">
```ballerina
// Book record type
public type Book record {|
    string id;
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

// Book request type for creating/updating books
public type BookRequest record {|
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

// Book category type
public type BookCategory record {|
    string categoryId;
    string categoryName;
    string description?;
|};

// Standardized error response type
public type ErrorResponse record {|
    *http:BadRequest;
    record {|
        string error;
    |} body;
|};

// Not found error response type
public type NotFoundErrorResponse record {|
    *http:NotFound;
    record {|
        string error;
    |} body;
|};

// Internal server error response type
public type InternalServerErrorResponse record {|
    *http:InternalServerError;
    record {|
        string error;
    |} body;
|};
```
</code>

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;

int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

// Helper function to validate and format book data
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    // Basic validation
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }
    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }
    if bookRequest.isbn.trim().length() == 0 {
        return error("Book ISBN cannot be empty");
    }
    if bookRequest.price <= 0.0 {
        return error("Book price must be greater than zero");
    }
    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    // Create a new book with generated ID
    Book newBook = {
        id: uuid:createType1AsString(),
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return newBook;
}

service /bookstore on new http:Listener(servicePort) {

    // Get a specific book by ID
    resource function get books/[string bookId]() returns Book|NotFoundErrorResponse|InternalServerErrorResponse {
        totalRequests += 1;

        if bookStore.hasKey(bookId) {
            Book book = bookStore.get(bookId);
            return book;
        }
        
        NotFoundErrorResponse notFoundError = {
            body: {
                error: "Book not found"
            }
        };
        return notFoundError;
    }

    // Get all books
    resource function get books() returns Book[]|InternalServerErrorResponse {
        totalRequests += 1;

        Book[] allBooks = bookStore.toArray();
        return allBooks;
    }

    // Create a new book
    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|ErrorResponse|InternalServerErrorResponse {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            ErrorResponse badRequestError = {
                body: {
                    error: validatedBook.message()
                }
            };
            return badRequestError;
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }

    // Update an existing book
    resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|NotFoundErrorResponse|ErrorResponse|InternalServerErrorResponse {
        totalRequests += 1;

        if !bookStore.hasKey(bookId) {
            NotFoundErrorResponse notFoundError = {
                body: {
                    error: "Book not found"
                }
            };
            return notFoundError;
        }

        // Validate the request data
        if bookRequest.title.trim().length() == 0 {
            ErrorResponse badRequestError = {
                body: {
                    error: "Book title cannot be empty"
                }
            };
            return badRequestError;
        }

        if bookRequest.author.trim().length() == 0 {
            ErrorResponse badRequestError = {
                body: {
                    error: "Book author cannot be empty"
                }
            };
            return badRequestError;
        }

        if bookRequest.price <= 0.0 {
            ErrorResponse badRequestError = {
                body: {
                    error: "Book price must be greater than zero"
                }
            };
            return badRequestError;
        }

        Book updatedBook = {
            id: bookId,
            title: bookRequest.title.trim(),
            author: bookRequest.author.trim(),
            isbn: bookRequest.isbn.trim(),
            price: bookRequest.price,
            quantity: bookRequest.quantity
        };

        bookStore[bookId] = updatedBook;
        return updatedBook;
    }

    // Delete a book
    resource function delete books/[string bookId]() returns http:NoContent|NotFoundErrorResponse|InternalServerErrorResponse {
        totalRequests += 1;

        if !bookStore.hasKey(bookId) {
            NotFoundErrorResponse notFoundError = {
                body: {
                    error: "Book not found"
                }
            };
            return notFoundError;
        }

        Book removedBook = bookStore.remove(bookId);
        return http:NO_CONTENT;
    }

    // Health check endpoint
    resource function get health() returns map<string>|InternalServerErrorResponse {
        totalRequests += 1;
        
        map<string> healthStatus = {
            "status": "UP", 
            "service": serviceName,
            "uptime": (time:utcNow()[0] - serviceStartTime[0]).toString(),
            "totalRequests": totalRequests.toString()
        };
        return healthStatus;
    }

    // Create a new book category
    resource function post categories(@http:Payload BookCategory category) returns http:Created|ErrorResponse|InternalServerErrorResponse {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            ErrorResponse badRequestError = {
                body: {
                    error: "Category name cannot be empty"
                }
            };
            return badRequestError;
        }

        if category.categoryId.trim().length() == 0 {
            ErrorResponse badRequestError = {
                body: {
                    error: "Category ID cannot be empty"
                }
            };
            return badRequestError;
        }

        if bookCategories.hasKey(category.categoryId) {
            ErrorResponse conflictError = {
                body: {
                    error: "Category with this ID already exists"
                }
            };
            return conflictError;
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }

    // Get all categories
    resource function get categories() returns BookCategory[]|InternalServerErrorResponse {
        totalRequests += 1;

        BookCategory[] allCategories = bookCategories.toArray();
        return allCategories;
    }

    // Get a specific category by ID
    resource function get categories/[string categoryId]() returns BookCategory|NotFoundErrorResponse|InternalServerErrorResponse {
        totalRequests += 1;

        if bookCategories.hasKey(categoryId) {
            BookCategory category = bookCategories.get(categoryId);
            return category;
        }

        NotFoundErrorResponse notFoundError = {
            body: {
                error: "Category not found"
            }
        };
        return notFoundError;
    }

    // Get service statistics
    resource function get stats() returns map<anydata>|InternalServerErrorResponse {
        totalRequests += 1;

        map<anydata> statistics = {
            "totalBooks": bookStore.length(),
            "totalCategories": bookCategories.length(),
            "totalRequests": totalRequests,
            "serviceStartTime": serviceStartTime[0],
            "uptime": time:utcNow()[0] - serviceStartTime[0]
        };
        return statistics;
    }
}
```
</code>

The key improvements in this standardized error handling approach:

1. **Consistent Error Structure**: All errors now return JSON objects with an `error` field containing the error message
2. **Proper HTTP Status Codes**: Using Ballerina's HTTP status record types to ensure correct status codes are returned
3. **Type Safety**: Each error response type is properly typed with the correct HTTP status and JSON body structure
4. **Better Error Messages**: More descriptive error messages that help clients understand what went wrong
5. **Comprehensive Coverage**: All possible error scenarios now return standardized JSON error responses

This implementation ensures that clients will always receive structured JSON responses for errors, making it much easier to handle errors programmatically while maintaining the appropriate HTTP status codes.