Looking at the existing code context, I can see that you have a bookstore service with a PUT endpoint for updating books and a validation function `validateAndFormatBook` that's currently only used by the POST endpoint. The goal is to modify the PUT endpoint to reuse this validation logic to ensure updates also validate for empty titles, negative prices, and other data integrity checks.

The current PUT endpoint simply checks if the book exists and then directly updates it without any validation. By integrating the `validateAndFormatBook` function, we can ensure consistent validation across both creation and update operations.

Here's the solution:

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/uuid;

// In-memory storage for books
map<Book> bookStore = {};

// Module level variables (assuming these exist based on context)
int totalRequests = 0;
int servicePort = 8080;

service /bookstore on new http:Listener(servicePort) {
    
    // Add a new book
    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }

    // Update an existing book
    resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|http:NotFound|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        if !bookStore.hasKey(bookId) {
            return http:NOT_FOUND;
        }

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        validatedBook.id = bookId;
        bookStore[bookId] = validatedBook;
        return validatedBook;
    }
}

// Utility function to validate and format book data
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    string bookId = uuid:createType1AsString();

    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}
```
</code>

The key changes made to the PUT endpoint are:

1. **Added validation logic**: The endpoint now calls `validateAndFormatBook(bookRequest)` to validate the incoming data before updating.

2. **Error handling**: If validation fails, the endpoint returns `http:BAD_REQUEST` instead of proceeding with invalid data.

3. **Preserve book ID**: After validation succeeds, the original `bookId` from the path parameter is assigned to the validated book to maintain the correct ID for the update operation.

4. **Consistent behavior**: Both POST and PUT endpoints now use the same validation logic, ensuring data integrity across all book operations.

This modification ensures that book updates go through the same rigorous validation as book creation, checking for empty titles, negative prices, negative quantities, and empty author names while also trimming whitespace from string fields.