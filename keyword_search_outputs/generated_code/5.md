I'll help you standardize the error responses in your bookstore API to always return JSON objects with error messages instead of plain HTTP status codes.

## Explanation

Looking at your existing code, I can see that you have a bookstore API with various endpoints for managing books and categories. Currently, some endpoints return plain HTTP status codes for errors, while others might return different response formats. To standardize this, I need to:

1. **Create utility functions** for consistent error and success response formatting
2. **Modify all resource functions** to use these utility functions
3. **Ensure all error responses** return a JSON object with an "error" field
4. **Maintain existing functionality** while standardizing the response format

The key changes will be:
- Adding `createErrorResponse()` and `createSuccessResponse()` utility functions
- Updating all resource functions to use these utilities
- Ensuring proper error handling throughout the API
- Maintaining the existing business logic while improving response consistency

This approach will provide a better developer experience for API consumers, as they can always expect a consistent JSON response format with meaningful error messages.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;

int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

// Utility functions for standardized responses
function createErrorResponse(string message, http:Status status = http:STATUS_INTERNAL_SERVER_ERROR) returns http:Response {
    http:Response response = new;
    response.statusCode = status;
    response.setJsonPayload({"error": message});
    return response;
}

function createSuccessResponse(string message, http:Status status = http:STATUS_OK) returns http:Response {
    http:Response response = new;
    response.statusCode = status;
    response.setJsonPayload({"message": message});
    return response;
}

function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.isbn.trim().length() == 0 {
        return error("Book ISBN cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    string bookId = uuid:createType1AsString();

    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}

service /bookstore on new http:Listener(servicePort) {

    // Get all books with pagination
    resource function get books(int page = 1, int pageSize = 10) returns http:Response {
        totalRequests += 1;

        if page < 1 {
            return createErrorResponse("Page number must be greater than 0", http:STATUS_BAD_REQUEST);
        }

        if pageSize < 1 || pageSize > maxBooksPerPage {
            return createErrorResponse($"Page size must be between 1 and {maxBooksPerPage}", http:STATUS_BAD_REQUEST);
        }

        Book[] allBooks = bookStore.toArray();
        int totalBooks = allBooks.length();
        int startIndex = (page - 1) * pageSize;

        if startIndex >= totalBooks && totalBooks > 0 {
            return createErrorResponse("Page number exceeds available data", http:STATUS_BAD_REQUEST);
        }

        int endIndex = startIndex + pageSize;
        if endIndex > totalBooks {
            endIndex = totalBooks;
        }

        Book[] pagedBooks = [];
        int index = startIndex;
        while index < endIndex {
            pagedBooks.push(allBooks[index]);
            index += 1;
        }

        BookListResponse bookListResponse = {
            books: pagedBooks,
            totalCount: totalBooks,
            page: page,
            pageSize: pageSize
        };

        http:Response response = new;
        response.statusCode = http:STATUS_OK;
        response.setJsonPayload(bookListResponse.toJson());
        return response;
    }

    // Get a specific book by ID
    resource function get books/[string bookId]() returns http:Response {
        totalRequests += 1;

        if bookId.trim().length() == 0 {
            return createErrorResponse("Book ID cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if bookStore.hasKey(bookId) {
            Book book = bookStore.get(bookId);
            http:Response response = new;
            response.statusCode = http:STATUS_OK;
            response.setJsonPayload(book.toJson());
            return response;
        }
        
        return createErrorResponse("Book not found", http:STATUS_NOT_FOUND);
    }

    // Create a new book
    resource function post books(@http:Payload BookRequest bookRequest) returns http:Response {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return createErrorResponse(validatedBook.message(), http:STATUS_BAD_REQUEST);
        }

        // Check if a book with the same ISBN already exists
        foreach Book existingBook in bookStore {
            if existingBook.isbn == validatedBook.isbn {
                return createErrorResponse("A book with this ISBN already exists", http:STATUS_CONFLICT);
            }
        }

        bookStore[validatedBook.id] = validatedBook;
        
        http:Response response = new;
        response.statusCode = http:STATUS_CREATED;
        response.setJsonPayload(validatedBook.toJson());
        return response;
    }

    // Update an existing book
    resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns http:Response {
        totalRequests += 1;

        if bookId.trim().length() == 0 {
            return createErrorResponse("Book ID cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if !bookStore.hasKey(bookId) {
            return createErrorResponse("Book not found", http:STATUS_NOT_FOUND);
        }

        // Validate the updated book data
        if bookRequest.title.trim().length() == 0 {
            return createErrorResponse("Book title cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if bookRequest.author.trim().length() == 0 {
            return createErrorResponse("Book author cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if bookRequest.isbn.trim().length() == 0 {
            return createErrorResponse("Book ISBN cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if bookRequest.price < 0.0d {
            return createErrorResponse("Book price cannot be negative", http:STATUS_BAD_REQUEST);
        }

        if bookRequest.quantity < 0 {
            return createErrorResponse("Book quantity cannot be negative", http:STATUS_BAD_REQUEST);
        }

        // Check if another book with the same ISBN already exists (excluding current book)
        foreach Book existingBook in bookStore {
            if existingBook.isbn == bookRequest.isbn && existingBook.id != bookId {
                return createErrorResponse("A book with this ISBN already exists", http:STATUS_CONFLICT);
            }
        }

        Book updatedBook = {
            id: bookId,
            title: bookRequest.title.trim(),
            author: bookRequest.author.trim(),
            isbn: bookRequest.isbn.trim(),
            price: bookRequest.price,
            quantity: bookRequest.quantity
        };

        bookStore[bookId] = updatedBook;
        
        http:Response response = new;
        response.statusCode = http:STATUS_OK;
        response.setJsonPayload(updatedBook.toJson());
        return response;
    }

    // Delete a book
    resource function delete books/[string bookId]() returns http:Response {
        totalRequests += 1;

        if bookId.trim().length() == 0 {
            return createErrorResponse("Book ID cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if !bookStore.hasKey(bookId) {
            return createErrorResponse("Book not found", http:STATUS_NOT_FOUND);
        }

        Book removedBook = bookStore.remove(bookId);
        return createSuccessResponse($"Book '{removedBook.title}' deleted successfully");
    }

    // Search books by title or author
    resource function get books/search(string query = "", string searchType = "title") returns http:Response {
        totalRequests += 1;

        if query.trim().length() == 0 {
            return createErrorResponse("Search query cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if searchType != "title" && searchType != "author" && searchType != "isbn" {
            return createErrorResponse("Search type must be 'title', 'author', or 'isbn'", http:STATUS_BAD_REQUEST);
        }

        Book[] matchedBooks = [];
        string lowerQuery = query.toLowerAscii();

        foreach Book book in bookStore {
            boolean isMatch = false;
            if searchType == "title" {
                isMatch = book.title.toLowerAscii().includes(lowerQuery);
            } else if searchType == "author" {
                isMatch = book.author.toLowerAscii().includes(lowerQuery);
            } else if searchType == "isbn" {
                isMatch = book.isbn.toLowerAscii().includes(lowerQuery);
            }

            if isMatch {
                matchedBooks.push(book);
            }
        }

        SearchResponse searchResponse = {
            books: matchedBooks,
            totalFound: matchedBooks.length(),
            searchQuery: query,
            searchType: searchType
        };

        http:Response response = new;
        response.statusCode = http:STATUS_OK;
        response.setJsonPayload(searchResponse.toJson());
        return response;
    }

    // Create a new category
    resource function post categories(@http:Payload BookCategory category) returns http:Response {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            return createErrorResponse("Category name cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if category.categoryId.trim().length() == 0 {
            return createErrorResponse("Category ID cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if bookCategories.hasKey(category.categoryId) {
            return createErrorResponse("Category with this ID already exists", http:STATUS_CONFLICT);
        }

        BookCategory newCategory = {
            categoryId: category.categoryId.trim(),
            categoryName: category.categoryName.trim(),
            description: category.description.trim()
        };

        bookCategories[newCategory.categoryId] = newCategory;
        
        http:Response response = new;
        response.statusCode = http:STATUS_CREATED;
        response.setJsonPayload(newCategory.toJson());
        return response;
    }

    // Get all categories
    resource function get categories() returns http:Response {
        totalRequests += 1;

        BookCategory[] allCategories = bookCategories.toArray();
        
        http:Response response = new;
        response.statusCode = http:STATUS_OK;
        response.setJsonPayload(allCategories.toJson());
        return response;
    }

    // Get category by ID
    resource function get categories/[string categoryId]() returns http:Response {
        totalRequests += 1;

        if categoryId.trim().length() == 0 {
            return createErrorResponse("Category ID cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if bookCategories.hasKey(categoryId) {
            BookCategory category = bookCategories.get(categoryId);
            http:Response response = new;
            response.statusCode = http:STATUS_OK;
            response.setJsonPayload(category.toJson());
            return response;
        }

        return createErrorResponse("Category not found", http:STATUS_NOT_FOUND);
    }

    // Update a category
    resource function put categories/[string categoryId](@http:Payload BookCategory category) returns http:Response {
        totalRequests += 1;

        if categoryId.trim().length() == 0 {
            return createErrorResponse("Category ID cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if !bookCategories.hasKey(categoryId) {
            return createErrorResponse("Category not found", http:STATUS_NOT_FOUND);
        }

        if category.categoryName.trim().length() == 0 {
            return createErrorResponse("Category name cannot be empty", http:STATUS_BAD_REQUEST);
        }

        BookCategory updatedCategory = {
            categoryId: categoryId,
            categoryName: category.categoryName.trim(),
            description: category.description.trim()
        };

        bookCategories[categoryId] = updatedCategory;
        
        http:Response response = new;
        response.statusCode = http:STATUS_OK;
        response.setJsonPayload(updatedCategory.toJson());
        return response;
    }

    // Delete a category
    resource function delete categories/[string categoryId]() returns http:Response {
        totalRequests += 1;

        if categoryId.trim().length() == 0 {
            return createErrorResponse("Category ID cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if !bookCategories.hasKey(categoryId) {
            return createErrorResponse("Category not found", http:STATUS_NOT_FOUND);
        }

        BookCategory removedCategory = bookCategories.remove(categoryId);
        return createSuccessResponse($"Category '{removedCategory.categoryName}' deleted successfully");
    }

    // Health check endpoint
    resource function get health() returns http:Response {
        totalRequests += 1;
        
        time:Utc currentTime = time:utcNow();
        decimal uptime = time:utcDiffSeconds(currentTime, serviceStartTime);
        
        HealthResponse healthResponse = {
            status: "UP",
            serviceName: serviceName,
            uptime: uptime,
            totalRequests: totalRequests,
            timestamp: currentTime.toString()
        };

        http:Response response = new;
        response.statusCode = http:STATUS_OK;
        response.setJsonPayload(healthResponse.toJson());
        return response;
    }

    // Get service statistics
    resource function get stats() returns http:Response {
        totalRequests += 1;

        time:Utc currentTime = time:utcNow();
        decimal uptime = time:utcDiffSeconds(currentTime, serviceStartTime);

        ServiceStats stats = {
            totalBooks: bookStore.length(),
            totalCategories: bookCategories.length(),
            totalRequests: totalRequests,
            uptime: uptime,
            serviceName: serviceName
        };

        http:Response response = new;
        response.statusCode = http:STATUS_OK;
        response.setJsonPayload(stats.toJson());
        return response;
    }
}
```
</code>

<code filename="types.bal">
```ballerina
// Book related types
public type Book record {|
    string id;
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type BookRequest record {|
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type BookListResponse record {|
    Book[] books;
    int totalCount;
    int page;
    int pageSize;
|};

public type SearchResponse record {|
    Book[] books;
    int totalFound;
    string searchQuery;
    string searchType;
|};

// Category related types
public type BookCategory record {|
    string categoryId;
    string categoryName;
    string description;
|};

// Service related types
public type HealthResponse record {|
    string status;
    string serviceName;
    decimal uptime;
    int totalRequests;
    string timestamp;
|};

public type ServiceStats record {|
    int totalBooks;
    int totalCategories;
    int totalRequests;
    decimal uptime;
    string serviceName;
|};

// Error response type
public type ErrorResponse record {|
    string 'error;
|};

// Success response type
public type SuccessResponse record {|
    string message;
|};
```
</code>