I'll help you standardize the error responses in your bookstore API to always return JSON objects with error messages instead of plain HTTP status codes. Based on the existing code, I can see that you already have utility functions `createErrorResponse` and `createSuccessResponse`, but let me ensure all error cases are properly handled with standardized JSON responses.

## Explanation

The goal is to modify the existing bookstore API to ensure that all error responses return a consistent JSON format with an error message field. This improves the API's usability by providing meaningful error information to clients in a predictable format.

Key changes needed:
1. Ensure all resource functions that can return errors use the `createErrorResponse` utility function
2. Modify any remaining direct HTTP status code returns to use standardized JSON responses
3. Update return types to include `http:Response` where necessary
4. Maintain consistency across all error scenarios

The existing utility functions `createErrorResponse` and `createSuccessResponse` provide the foundation for this standardization. I'll ensure all error cases throughout the API use these functions consistently.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;

int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

service /bookstore on new http:Listener(servicePort) {

    resource function get books() returns Book[]|http:Response {
        totalRequests += 1;
        return bookStore.toArray();
    }

    resource function get books/[string bookId]() returns Book|http:Response {
        totalRequests += 1;

        if bookStore.hasKey(bookId) {
            Book book = bookStore.get(bookId);
            return book;
        }
        return createErrorResponse("Book not found", http:STATUS_NOT_FOUND);
    }

    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:Response {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return createErrorResponse(validatedBook.message(), http:STATUS_BAD_REQUEST);
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }

    resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|http:Response {
        totalRequests += 1;

        if !bookStore.hasKey(bookId) {
            return createErrorResponse("Book not found", http:STATUS_NOT_FOUND);
        }

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return createErrorResponse(validatedBook.message(), http:STATUS_BAD_REQUEST);
        }

        Book updatedBook = {
            id: bookId,
            title: validatedBook.title,
            author: validatedBook.author,
            isbn: validatedBook.isbn,
            price: validatedBook.price,
            quantity: validatedBook.quantity
        };

        bookStore[bookId] = updatedBook;
        return updatedBook;
    }

    resource function delete books/[string bookId]() returns http:Response {
        totalRequests += 1;

        if !bookStore.hasKey(bookId) {
            return createErrorResponse("Book not found", http:STATUS_NOT_FOUND);
        }

        Book removedBook = bookStore.remove(bookId);
        return createSuccessResponse("Book deleted successfully", http:STATUS_OK);
    }

    resource function get categories() returns BookCategory[]|http:Response {
        totalRequests += 1;
        return bookCategories.toArray();
    }

    resource function get categories/[string categoryId]() returns BookCategory|http:Response {
        totalRequests += 1;

        if bookCategories.hasKey(categoryId) {
            BookCategory category = bookCategories.get(categoryId);
            return category;
        }
        return createErrorResponse("Category not found", http:STATUS_NOT_FOUND);
    }

    resource function post categories(@http:Payload BookCategory category) returns http:Created|http:Response {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            return createErrorResponse("Category name cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if category.categoryId.trim().length() == 0 {
            return createErrorResponse("Category ID cannot be empty", http:STATUS_BAD_REQUEST);
        }

        if bookCategories.hasKey(category.categoryId) {
            return createErrorResponse("Category already exists", http:STATUS_CONFLICT);
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }

    resource function put categories/[string categoryId](@http:Payload BookCategory category) returns BookCategory|http:Response {
        totalRequests += 1;

        if !bookCategories.hasKey(categoryId) {
            return createErrorResponse("Category not found", http:STATUS_NOT_FOUND);
        }

        if category.categoryName.trim().length() == 0 {
            return createErrorResponse("Category name cannot be empty", http:STATUS_BAD_REQUEST);
        }

        BookCategory updatedCategory = {
            categoryId: categoryId,
            categoryName: category.categoryName,
            description: category.description
        };

        bookCategories[categoryId] = updatedCategory;
        return updatedCategory;
    }

    resource function delete categories/[string categoryId]() returns http:Response {
        totalRequests += 1;

        if !bookCategories.hasKey(categoryId) {
            return createErrorResponse("Category not found", http:STATUS_NOT_FOUND);
        }

        BookCategory removedCategory = bookCategories.remove(categoryId);
        return createSuccessResponse("Category deleted successfully", http:STATUS_OK);
    }
}

service /admin on new http:Listener(servicePort) {

    resource function get stats() returns http:Response {
        ApiStats stats = {
            totalRequests: totalRequests,
            totalBooks: bookStore.length(),
            totalCategories: bookCategories.length(),
            uptime: time:utcDiffSeconds(time:utcNow(), serviceStartTime),
            serviceName: serviceName
        };
        
        http:Response response = new;
        response.statusCode = http:STATUS_OK;
        response.setPayload(stats);
        return response;
    }

    resource function post reset() returns http:Response {
        bookStore.removeAll();
        bookCategories.removeAll();
        totalRequests = 0;
        serviceStartTime = time:utcNow();
        
        return createSuccessResponse("System reset successfully", http:STATUS_OK);
    }

    resource function get health() returns http:Response {
        HealthCheck health = {
            status: "healthy",
            timestamp: time:utcNow(),
            version: "1.0.0"
        };
        
        http:Response response = new;
        response.statusCode = http:STATUS_OK;
        response.setPayload(health);
        return response;
    }
}

// Utility function to create standardized error responses
function createErrorResponse(string message, http:StatusCode statusCode) returns http:Response {
    http:Response response = new;
    response.statusCode = statusCode;
    response.setPayload({error: message});
    return response;
}

// Utility function to create standardized success responses
function createSuccessResponse(string message, http:StatusCode statusCode) returns http:Response {
    http:Response response = new;
    response.statusCode = statusCode;
    response.setPayload({message: message});
    return response;
}

// Existing utility function
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.isbn.trim().length() == 0 {
        return error("Book ISBN cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    string bookId = uuid:createType1AsString();

    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}
```
</code>

<code filename="types.bal">
```ballerina
public type Book record {|
    string id;
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type BookRequest record {|
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type BookCategory record {|
    string categoryId;
    string categoryName;
    string description;
|};

public type ApiStats record {|
    int totalRequests;
    int totalBooks;
    int totalCategories;
    decimal uptime;
    string serviceName;
|};

public type HealthCheck record {|
    string status;
    string timestamp;
    string version;
|};
```
</code>