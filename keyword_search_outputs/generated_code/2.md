Looking at your existing code, I can see that you have a `validateAndFormatBook` function that performs comprehensive validation for book data, including checks for empty titles, empty authors, negative prices, and negative quantities. Currently, your PUT endpoint for updating books doesn't use this validation logic, which means updates could potentially bypass these important data integrity checks.

The modification will involve updating the PUT `/books/{bookId}` endpoint to use the existing `validateAndFormatBook` function before updating the book in the store. This ensures that all book updates go through the same validation process as book creation, maintaining consistent data validation across your API.

The key changes will be:
1. Call `validateAndFormatBook` with the incoming `bookRequest`
2. Handle validation errors by returning `http:BAD_REQUEST`
3. If validation passes, update the book ID to maintain the existing book's ID
4. Store the validated book data

This approach ensures that book updates are subject to the same validation rules as book creation, preventing invalid data from being stored through updates.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/uuid;

// In-memory storage for books
map<Book> bookStore = {};

// Module level variables
int totalRequests = 0;
configurable int servicePort = 8080;

service /bookstore on new http:Listener(servicePort) {
    
    // Add a new book
    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }

    // Update an existing book
    resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|http:NotFound|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        if !bookStore.hasKey(bookId) {
            return http:NOT_FOUND;
        }

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        validatedBook.id = bookId;
        bookStore[bookId] = validatedBook;
        return validatedBook;
    }

    // Get all books
    resource function get books() returns Book[] {
        totalRequests += 1;
        return bookStore.toArray();
    }

    // Get a specific book
    resource function get books/[string bookId]() returns Book|http:NotFound {
        totalRequests += 1;
        
        if bookStore.hasKey(bookId) {
            Book book = bookStore.get(bookId);
            return book;
        }
        return http:NOT_FOUND;
    }

    // Delete a book
    resource function delete books/[string bookId]() returns http:NoContent|http:NotFound {
        totalRequests += 1;
        
        if bookStore.hasKey(bookId) {
            Book removedBook = bookStore.remove(bookId);
            return http:NO_CONTENT;
        }
        return http:NOT_FOUND;
    }
}

// Utility function to validate and format book data
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    string bookId = uuid:createType1AsString();

    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}
```
</code>