I'll modify the PUT /books/{bookId} endpoint to reuse the existing validation logic from the `validateAndFormatBook` function. This will ensure that book updates undergo the same validation checks as book creation, including empty title validation, negative price checks, and other business rules.

The key changes are:
1. Call `validateAndFormatBook` with the incoming `bookRequest` in the PUT endpoint
2. Handle validation errors by returning `http:BAD_REQUEST`
3. If validation passes, use the validated book data but preserve the existing `bookId`
4. Update the book store with the validated and formatted data

This approach ensures consistency in validation logic across both POST (create) and PUT (update) operations, making the code more maintainable and ensuring data integrity.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/uuid;

// Configuration
configurable int servicePort = 9090;

// Module level variables
map<Book> bookStore = {};
int totalRequests = 0;

// Types
type Book record {
    string id;
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
};

type BookRequest record {
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
};

// Validation function
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    string bookId = uuid:createType1AsString();

    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}

// Service
service /bookstore on new http:Listener(servicePort) {
    
    // Create a new book
    resource function post books(@http:Payload BookRequest bookRequest) returns Book|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        bookStore[validatedBook.id] = validatedBook;
        return validatedBook;
    }

    // Update an existing book
    resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|http:NotFound|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        if !bookStore.hasKey(k = bookId) {
            return http:NOT_FOUND;
        }

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        validatedBook.id = bookId;
        bookStore[bookId] = validatedBook;
        return validatedBook;
    }

    // Get a book by ID
    resource function get books/[string bookId]() returns Book|http:NotFound {
        totalRequests += 1;

        if !bookStore.hasKey(k = bookId) {
            return http:NOT_FOUND;
        }

        Book book = bookStore.get(k = bookId);
        return book;
    }

    // Get all books
    resource function get books() returns Book[] {
        totalRequests += 1;
        return bookStore.toArray();
    }

    // Delete a book
    resource function delete books/[string bookId]() returns http:NoContent|http:NotFound {
        totalRequests += 1;

        if !bookStore.hasKey(k = bookId) {
            return http:NOT_FOUND;
        }

        Book _ = bookStore.remove(k = bookId);
        return http:NO_CONTENT;
    }

    // Health check endpoint
    resource function get health() returns json {
        return {
            status: "UP",
            totalRequests: totalRequests
        };
    }
}
```
</code>