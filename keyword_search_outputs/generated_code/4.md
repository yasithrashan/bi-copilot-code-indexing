Based on the existing code context, I can see that you already have a category service with POST and GET operations, and the code has been expanded to include PUT and DELETE operations. However, let me provide a complete, clean implementation that extends the category service with proper update and delete operations.

The expanded service will include:
- **PUT** operation for updating existing categories
- **DELETE** operation for removing categories
- Proper error handling with appropriate HTTP status codes
- Validation for category data
- Consistent request counting for all operations

The PUT operation will update a category by its ID, validate the input data, and return the updated category or appropriate error responses. The DELETE operation will remove a category by its ID and return a 204 No Content status on success or 404 Not Found if the category doesn't exist.

<code filename="types.bal">
```ballerina
// Book category type definition
public type BookCategory record {
    string categoryId;
    string categoryName;
    string? description?;
};
```
</code>

<code filename="main.bal">
```ballerina
import ballerina/http;

// Configuration variables
configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";

// Module level variables
int totalRequests = 0;
map<BookCategory> bookCategories = {};

// Admin service for category management
service /admin on new http:Listener(servicePort) {

    // Add book category
    resource function post categories(@http:Payload BookCategory category) returns http:Created|http:BadRequest {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            return http:BAD_REQUEST;
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }

    // Get all categories
    resource function get categories() returns BookCategory[] {
        totalRequests += 1;
        return bookCategories.toArray();
    }

    // Update a category
    resource function put categories/[string categoryId](@http:Payload BookCategory category) returns BookCategory|http:NotFound|http:BadRequest {
        totalRequests += 1;

        if !bookCategories.hasKey(categoryId) {
            return http:NOT_FOUND;
        }

        if category.categoryName.trim().length() == 0 {
            return http:BAD_REQUEST;
        }

        // Ensure the category ID matches the path parameter
        category.categoryId = categoryId;
        bookCategories[categoryId] = category;
        return category;
    }

    // Delete a category
    resource function delete categories/[string categoryId]() returns http:NoContent|http:NotFound {
        totalRequests += 1;

        if !bookCategories.hasKey(categoryId) {
            return http:NOT_FOUND;
        }

        BookCategory removedCategory = bookCategories.remove(categoryId);
        return http:NO_CONTENT;
    }

    // Health check endpoint
    resource function get health() returns map<string> {
        totalRequests += 1;
        return {"status": "UP", "service": serviceName, "totalRequests": totalRequests.toString()};
    }
}
```
</code>