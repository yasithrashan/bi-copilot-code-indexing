I'll extend the existing category service to support update and delete operations. Looking at the existing code context, I can see there's already a bookstore API with category management functionality, and I need to add PUT and DELETE operations for individual categories.

## Explanation

The current service has POST and GET operations for categories. I'll add:

1. **PUT operation** (`put categories/[string categoryId]`) - to update an existing category
2. **DELETE operation** (`delete categories/[string categoryId]`) - to remove a category

Both operations will:
- Use path parameters to identify the specific category by ID
- Include proper error handling (404 for not found, 400 for bad request)
- Maintain the existing request counting mechanism
- Follow RESTful conventions with appropriate HTTP status codes

The PUT operation will validate the updated category data and replace the existing category if found. The DELETE operation will remove the category from the storage map and return appropriate status codes.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

// Configuration Variables
configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";

// Module Level Variables
int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};

// Types
type BookCategory record {|
    string categoryId;
    string categoryName;
    string? description;
|};

type ServiceStats record {|
    int totalRequests;
    string uptime;
    int categoryCount;
|};

// Services
service /admin on new http:Listener(servicePort) {
    
    resource function get stats() returns ServiceStats {
        totalRequests += 1;
        time:Utc currentTime = time:utcNow();
        time:Seconds uptime = time:utcDiffSeconds(currentTime, serviceStartTime);
        
        return {
            totalRequests: totalRequests,
            uptime: string `${uptime}s`,
            categoryCount: bookCategories.length()
        };
    }

    resource function get health() returns map<string> {
        totalRequests += 1;
        return {"status": "UP", "service": serviceName};
    }

    resource function post categories(@http:Payload BookCategory category) returns http:Created|http:BadRequest {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            return http:BAD_REQUEST;
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }

    resource function get categories() returns BookCategory[] {
        totalRequests += 1;
        return bookCategories.toArray();
    }

    resource function put categories/[string categoryId](@http:Payload BookCategory updatedCategory) returns http:Ok|http:NotFound|http:BadRequest {
        totalRequests += 1;

        if !bookCategories.hasKey(categoryId) {
            return http:NOT_FOUND;
        }

        if updatedCategory.categoryName.trim().length() == 0 {
            return http:BAD_REQUEST;
        }

        // Ensure the categoryId in the payload matches the path parameter
        BookCategory categoryToUpdate = {
            categoryId: categoryId,
            categoryName: updatedCategory.categoryName,
            description: updatedCategory.description
        };

        bookCategories[categoryId] = categoryToUpdate;
        return http:OK;
    }

    resource function delete categories/[string categoryId]() returns http:NoContent|http:NotFound {
        totalRequests += 1;

        if !bookCategories.hasKey(categoryId) {
            return http:NOT_FOUND;
        }

        _ = bookCategories.remove(categoryId);
        return http:NO_CONTENT;
    }
}
```
</code>