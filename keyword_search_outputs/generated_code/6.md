Looking at the existing code context, I can see there are already two HTTP servers running on the same port (8080): `/bookstore` and `/admin`. To add a new HTTP server, I'll create a third service that runs on a different port to avoid conflicts.

The new HTTP server will be a general-purpose service called `/api` that runs on port 8081. It will include basic functionality like health checks, system information, and a simple echo endpoint to demonstrate different types of HTTP operations. This follows the same pattern as the existing services but provides additional functionality that complements the bookstore and admin services.

The new service will include:
- A health check endpoint
- A system info endpoint that returns server details
- An echo endpoint for testing POST requests
- A simple greeting endpoint with path parameters

This implementation maintains consistency with the existing code structure while adding new capabilities through a separate service on a different port.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

configurable int servicePort = 8080;
configurable int apiServicePort = 8081;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;

int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

// Existing HTTP server for bookstore
service /bookstore on new http:Listener(servicePort) {
    
    resource function get books(int page = 1, int 'limit = maxBooksPerPage) returns PaginatedBooks|http:InternalServerError {
        totalRequests += 1;
        
        if debugMode {
            // Debug logging could be added here
        }

        Book[] allBooks = bookStore.toArray();
        int totalBooks = allBooks.length();
        
        if totalBooks == 0 {
            return {
                books: [],
                totalBooks: 0,
                currentPage: page,
                totalPages: 0,
                hasNext: false,
                hasPrevious: false
            };
        }

        int startIndex = (page - 1) * 'limit;
        int endIndex = startIndex + 'limit;
        
        if startIndex >= totalBooks {
            return http:INTERNAL_SERVER_ERROR;
        }

        if endIndex > totalBooks {
            endIndex = totalBooks;
        }

        Book[] pagedBooks = [];
        int index = 0;
        foreach Book book in allBooks {
            if index >= startIndex && index < endIndex {
                pagedBooks.push(book);
            }
            index += 1;
        }

        int totalPages = (totalBooks + 'limit - 1) / 'limit;
        
        return {
            books: pagedBooks,
            totalBooks: totalBooks,
            currentPage: page,
            totalPages: totalPages,
            hasNext: page < totalPages,
            hasPrevious: page > 1
        };
    }

    resource function get books/[string bookId]() returns Book|http:NotFound|http:InternalServerError {
        totalRequests += 1;
        
        if !bookStore.hasKey(bookId) {
            return http:NOT_FOUND;
        }
        
        Book book = bookStore.get(bookId);
        return book;
    }

    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }

    resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|http:NotFound|http:BadRequest|http:InternalServerError {
        totalRequests += 1;
        
        if !bookStore.hasKey(bookId) {
            return http:NOT_FOUND;
        }

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        Book updatedBook = {
            id: bookId,
            title: validatedBook.title,
            author: validatedBook.author,
            isbn: validatedBook.isbn,
            publishedYear: validatedBook.publishedYear,
            genre: validatedBook.genre,
            price: validatedBook.price,
            availability: validatedBook.availability
        };

        bookStore[bookId] = updatedBook;
        return updatedBook;
    }

    resource function delete books/[string bookId]() returns http:NoContent|http:NotFound|http:InternalServerError {
        totalRequests += 1;
        
        if !bookStore.hasKey(bookId) {
            return http:NOT_FOUND;
        }
        
        Book removedBook = bookStore.remove(bookId);
        return http:NO_CONTENT;
    }

    resource function post books/search(@http:Payload BookSearchCriteria searchCriteria) returns Book[]|http:InternalServerError {
        totalRequests += 1;
        
        Book[] allBooks = bookStore.toArray();
        Book[] matchedBooks = [];

        foreach Book book in allBooks {
            boolean matches = true;
            
            if searchCriteria.title is string {
                string searchTitle = <string>searchCriteria.title;
                if !book.title.includes(searchTitle) {
                    matches = false;
                }
            }
            
            if searchCriteria.author is string {
                string searchAuthor = <string>searchCriteria.author;
                if !book.author.includes(searchAuthor) {
                    matches = false;
                }
            }
            
            if searchCriteria.genre is string {
                string searchGenre = <string>searchCriteria.genre;
                if book.genre != searchGenre {
                    matches = false;
                }
            }
            
            if matches {
                matchedBooks.push(book);
            }
        }
        
        return matchedBooks;
    }

    resource function get health() returns map<string> {
        totalRequests += 1;
        return {"status": "UP", "service": serviceName};
    }
}

// Existing HTTP server for admin
service /admin on new http:Listener(servicePort) {
    
    resource function get stats() returns ServiceStats {
        totalRequests += 1;
        
        time:Utc currentTime = time:utcNow();
        decimal uptime = time:utcDiffSeconds(currentTime, serviceStartTime);
        
        return {
            totalRequests: totalRequests,
            totalBooks: bookStore.length(),
            totalCategories: bookCategories.length(),
            uptime: uptime,
            serviceName: serviceName,
            debugMode: debugMode
        };
    }

    resource function post categories(@http:Payload BookCategory category) returns http:Created|http:BadRequest {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            return http:BAD_REQUEST;
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }

    resource function get categories() returns BookCategory[] {
        totalRequests += 1;
        return bookCategories.toArray();
    }
}

// New HTTP server for general API operations
service /api on new http:Listener(apiServicePort) {
    
    resource function get health() returns map<string> {
        totalRequests += 1;
        return {
            "status": "UP", 
            "service": "General API", 
            "port": apiServicePort.toString(),
            "timestamp": time:utcNow().toString()
        };
    }
    
    resource function get info() returns SystemInfo {
        totalRequests += 1;
        
        time:Utc currentTime = time:utcNow();
        decimal uptime = time:utcDiffSeconds(currentTime, serviceStartTime);
        
        return {
            serverName: "Ballerina API Server",
            version: "1.0.0",
            uptime: uptime,
            totalRequests: totalRequests,
            currentTime: currentTime.toString(),
            ports: {
                bookstore: servicePort,
                admin: servicePort,
                api: apiServicePort
            }
        };
    }
    
    resource function post echo(@http:Payload json message) returns EchoResponse|http:BadRequest {
        totalRequests += 1;
        
        if message is () {
            return http:BAD_REQUEST;
        }
        
        string requestId = uuid:createType1AsString();
        time:Utc timestamp = time:utcNow();
        
        return {
            requestId: requestId,
            timestamp: timestamp.toString(),
            originalMessage: message,
            messageType: "echo",
            processed: true
        };
    }
    
    resource function get greet/[string name]() returns GreetingResponse {
        totalRequests += 1;
        
        time:Utc currentTime = time:utcNow();
        
        return {
            message: "Hello, " + name + "!",
            timestamp: currentTime.toString(),
            requestCount: totalRequests
        };
    }
    
    resource function get status() returns ApiStatus {
        totalRequests += 1;
        
        return {
            apiName: "General API",
            status: "active",
            endpoints: [
                "/api/health",
                "/api/info", 
                "/api/echo",
                "/api/greet/{name}",
                "/api/status"
            ],
            totalEndpoints: 5
        };
    }
}

function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Title cannot be empty");
    }
    
    if bookRequest.author.trim().length() == 0 {
        return error("Author cannot be empty");
    }
    
    if bookRequest.isbn.trim().length() == 0 {
        return error("ISBN cannot be empty");
    }
    
    if bookRequest.publishedYear < 1000 || bookRequest.publishedYear > 2024 {
        return error("Invalid published year");
    }
    
    if bookRequest.price < 0 {
        return error("Price cannot be negative");
    }
    
    string bookId = uuid:createType1AsString();
    
    return {
        id: bookId,
        title: bookRequest.title,
        author: bookRequest.author,
        isbn: bookRequest.isbn,
        publishedYear: bookRequest.publishedYear,
        genre: bookRequest.genre,
        price: bookRequest.price,
        availability: bookRequest.availability
    };
}
```
</code>

<code filename="types.bal">
```ballerina
// Existing types
public type Book record {
    string id;
    string title;
    string author;
    string isbn;
    int publishedYear;
    string genre;
    decimal price;
    boolean availability;
};

public type BookRequest record {
    string title;
    string author;
    string isbn;
    int publishedYear;
    string genre;
    decimal price;
    boolean availability;
};

public type BookCategory record {
    string categoryId;
    string categoryName;
    string description;
};

public type BookSearchCriteria record {
    string? title;
    string? author;
    string? genre;
};

public type PaginatedBooks record {
    Book[] books;
    int totalBooks;
    int currentPage;
    int totalPages;
    boolean hasNext;
    boolean hasPrevious;
};

public type ServiceStats record {
    int totalRequests;
    int totalBooks;
    int totalCategories;
    decimal uptime;
    string serviceName;
    boolean debugMode;
};

// New types for the API service
public type SystemInfo record {
    string serverName;
    string version;
    decimal uptime;
    int totalRequests;
    string currentTime;
    record {
        int bookstore;
        int admin;
        int api;
    } ports;
};

public type EchoResponse record {
    string requestId;
    string timestamp;
    json originalMessage;
    string messageType;
    boolean processed;
};

public type GreetingResponse record {
    string message;
    string timestamp;
    int requestCount;
};

public type ApiStatus record {
    string apiName;
    string status;
    string[] endpoints;
    int totalEndpoints;
};
```
</code>