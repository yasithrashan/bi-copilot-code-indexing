# Ballerina Code Expansion

**Query:** Standardize the error responses so they always return a JSON object with an error message (e.g., { \"error\": \"Book not found\" }) instead of just plain HTTP status codes.

---

Based on the user query and the relevant code chunks provided, I'll expand and organize the existing code to show how we can standardize error responses. We'll focus on the main.bal file, as it contains the service definitions and resource functions.

## Filename: main.bal

## Imports

```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;
```

## Configuration Variables

```ballerina
configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;
```

## Module Level Variables

```ballerina
int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};
```

## Services

```ballerina
service /bookstore on new http:Listener(servicePort) {
    // ... existing resource functions ...
}

service /admin on new http:Listener(servicePort) {
    // ... existing resource functions ...
}
```

## Resources

```ballerina
resource function get books/[string bookId]() returns Book|http:Response {
    totalRequests += 1;

    if bookStore.hasKey(k = bookId) {
        Book book = bookStore.get(k = bookId);
        return book;
    }
    return createErrorResponse("Book not found", http:STATUS_NOT_FOUND);
}

resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:Response {
    totalRequests += 1;

    Book|error validatedBook = validateAndFormatBook(bookRequest);
    if validatedBook is error {
        return createErrorResponse(validatedBook.message(), http:STATUS_BAD_REQUEST);
    }

    bookStore[validatedBook.id] = validatedBook;
    return http:CREATED;
}

resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|http:Response {
    totalRequests += 1;

    if !bookStore.hasKey(k = bookId) {
        return createErrorResponse("Book not found", http:STATUS_NOT_FOUND);
    }

    Book updatedBook = {
        id: bookId,
        title: bookRequest.title,
        author: bookRequest.author,
        isbn: bookRequest.isbn,
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    bookStore[bookId] = updatedBook;
    return updatedBook;
}

resource function delete books/[string bookId]() returns http:Response {
    totalRequests += 1;

    if !bookStore.hasKey(k = bookId) {
        return createErrorResponse("Book not found", http:STATUS_NOT_FOUND);
    }

    Book removedBook = bookStore.remove(k = bookId);
    return createSuccessResponse("Book deleted successfully", http:STATUS_NO_CONTENT);
}

resource function post categories(@http:Payload BookCategory category) returns http:Created|http:Response {
    totalRequests += 1;

    if category.categoryName.trim().length() == 0 {
        return createErrorResponse("Category name cannot be empty", http:STATUS_BAD_REQUEST);
    }

    bookCategories[category.categoryId] = category;
    return http:CREATED;
}
```

## Matching Resources

```ballerina
// Utility function to create standardized error responses
function createErrorResponse(string message, http:StatusCode statusCode) returns http:Response {
    http:Response response = new;
    response.statusCode = statusCode;
    response.setPayload({ error: message });
    return response;
}

// Utility function to create standardized success responses
function createSuccessResponse(string message, http:StatusCode statusCode) returns http:Response {
    http:Response response = new;
    response.statusCode = statusCode;
    response.setPayload({ message: message });
    return response;
}

// Existing utility function
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    string bookId = uuid:createType1AsString();

    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}
```

This expanded and organized code demonstrates how to standardize error responses in the Bookstore API. The main changes include:

1. Creating utility functions `createErrorResponse` and `createSuccessResponse` to generate standardized JSON responses with appropriate status codes.
2. Modifying resource functions to use these utility functions for error cases, ensuring that all error responses follow the same format.
3. Updating return types of resource functions to include `http:Response` where necessary, allowing for custom responses.

These changes ensure that error responses always return a JSON object with an error message, as requested in the user query. The existing code structure and logic remain intact, with only the response handling being modified to meet the new requirements.

---
