# Ballerina Code Expansion

**Query:** Modify the PUT /books/{bookId} endpoint to reuse the validation logic (validateAndFormatBook) so updates also check for empty titles, negative prices, etc.

---

Based on the user query and the relevant code chunks provided, I'll expand and organize the existing code to show how the PUT /books/{bookId} endpoint can be modified to reuse the validation logic. Here's the expanded and organized code:

## Filename: main.bal

## Imports
```ballerina
import ballerina/http;
import ballerina/uuid;
```

## Module Level Variables
```ballerina
// In-memory storage for books
map<Book> bookStore = {};
```

## Services
```ballerina
service /bookstore on new http:Listener(servicePort) {
    // Other resources...

    // Update an existing book
    resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|http:NotFound|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        if !bookStore.hasKey(k = bookId) {
            return http:NOT_FOUND;
        }

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        validatedBook.id = bookId;
        bookStore[bookId] = validatedBook;
        return validatedBook;
    }

    // Other resources...
}
```

## Resources
```ballerina
// Utility function to validate and format book data
function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    string bookId = uuid:createType1AsString();

    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}
```

## Matching Resources
```ballerina
// Add a new book
resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:BadRequest|http:InternalServerError {
    totalRequests += 1;

    Book|error validatedBook = validateAndFormatBook(bookRequest);
    if validatedBook is error {
        return http:BAD_REQUEST;
    }

    bookStore[validatedBook.id] = validatedBook;
    return http:CREATED;
}
```

This expanded code shows how the PUT /books/{bookId} endpoint can be modified to reuse the validateAndFormatBook function for validation. The main changes are:

1. The PUT endpoint now uses the validateAndFormatBook function to validate and format the incoming book request.
2. If the validation fails, it returns a BAD_REQUEST response.
3. If the validation succeeds, it uses the validated book data to update the existing book in the bookStore.

The validateAndFormatBook function remains unchanged, as it already performs the necessary validations for empty titles, negative prices, etc. The POST /books endpoint is included as a matching resource to show how it also uses the same validation logic.

This approach ensures consistent validation across both the creation and update operations for books.

---
