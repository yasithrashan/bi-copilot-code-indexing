I'll add a new HTTP server to your existing implementation. Looking at your current code, you already have three services running:

1. `/bookstore` service on port 8080
2. `/admin` service on port 8080 (same listener as bookstore)
3. A root service `/` on port 8081

I'll add a new HTTP server on port 8082 that provides health check and system statistics functionality to complement your existing bookstore API.

The new server will include:
- A health check endpoint to verify service status
- A statistics endpoint to show system metrics like total requests and uptime
- A service information endpoint to display service configuration

This new server will run independently on its own port and provide monitoring capabilities for your bookstore system.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

configurable int servicePort = 8080;
configurable string serviceName = "Bookstore API";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;

int totalRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

service /bookstore on new http:Listener(servicePort) {
    resource function get books(int page = 1, int 'limit = maxBooksPerPage) returns PaginatedBooks|http:InternalServerError {
        totalRequests += 1;

        Book[] allBooks = bookStore.toArray();
        int totalCount = allBooks.length();
        int startIndex = (page - 1) * 'limit;
        int endIndex = startIndex + 'limit;

        if startIndex >= totalCount {
            PaginatedBooks emptyResult = {
                books: [],
                totalCount: totalCount,
                currentPage: page,
                totalPages: (totalCount + 'limit - 1) / 'limit
            };
            return emptyResult;
        }

        if endIndex > totalCount {
            endIndex = totalCount;
        }

        Book[] paginatedBooks = [];
        int index = startIndex;
        while index < endIndex {
            paginatedBooks.push(allBooks[index]);
            index += 1;
        }

        PaginatedBooks result = {
            books: paginatedBooks,
            totalCount: totalCount,
            currentPage: page,
            totalPages: (totalCount + 'limit - 1) / 'limit
        };

        return result;
    }

    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }

    resource function post books/search(@http:Payload BookSearchCriteria searchCriteria) returns Book[]|http:InternalServerError {
        totalRequests += 1;

        Book[] allBooks = bookStore.toArray();
        Book[] filteredBooks = [];

        foreach Book book in allBooks {
            boolean matches = true;

            string? titleCriteria = searchCriteria.title;
            if titleCriteria is string {
                if !book.title.toLowerAscii().includes(titleCriteria.toLowerAscii()) {
                    matches = false;
                }
            }

            string? authorCriteria = searchCriteria.author;
            if authorCriteria is string && matches {
                if !book.author.toLowerAscii().includes(authorCriteria.toLowerAscii()) {
                    matches = false;
                }
            }

            string? isbnCriteria = searchCriteria.isbn;
            if isbnCriteria is string && matches {
                if !book.isbn.includes(isbnCriteria) {
                    matches = false;
                }
            }

            decimal? minPriceCriteria = searchCriteria.minPrice;
            if minPriceCriteria is decimal && matches {
                if book.price < minPriceCriteria {
                    matches = false;
                }
            }

            decimal? maxPriceCriteria = searchCriteria.maxPrice;
            if maxPriceCriteria is decimal && matches {
                if book.price > maxPriceCriteria {
                    matches = false;
                }
            }

            if matches {
                filteredBooks.push(book);
            }
        }

        return filteredBooks;
    }
}

service /admin on new http:Listener(servicePort) {
    resource function post categories(@http:Payload BookCategory category) returns http:Created|http:BadRequest {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            return http:BAD_REQUEST;
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }
}

service / on new http:Listener(8081) {
    resource function get greeting() returns string {
        return "Hello, World!";
    }
}

// New HTTP server on port 8082
service /monitor on new http:Listener(8082) {
    
    resource function get health() returns HealthStatus {
        HealthStatus healthStatus = {
            status: "UP",
            timestamp: time:utcNow(),
            serviceName: serviceName,
            version: "1.0.0"
        };
        return healthStatus;
    }
    
    resource function get stats() returns ServiceStats {
        time:Utc currentTime = time:utcNow();
        decimal uptimeSeconds = time:utcDiffSeconds(currentTime, serviceStartTime);
        
        ServiceStats serviceStats = {
            totalRequests: totalRequests,
            uptimeSeconds: uptimeSeconds,
            totalBooks: bookStore.length(),
            totalCategories: bookCategories.length(),
            debugMode: debugMode
        };
        return serviceStats;
    }
    
    resource function get info() returns ServiceInfo {
        ServiceInfo serviceInfo = {
            serviceName: serviceName,
            servicePort: servicePort,
            maxBooksPerPage: maxBooksPerPage,
            startTime: serviceStartTime
        };
        return serviceInfo;
    }
}

function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }
    
    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }
    
    if bookRequest.price < 0 {
        return error("Book price cannot be negative");
    }
    
    string bookId = uuid:createType4AsString();
    
    Book validatedBook = {
        id: bookId,
        title: bookRequest.title,
        author: bookRequest.author,
        isbn: bookRequest.isbn,
        price: bookRequest.price
    };
    
    return validatedBook;
}
```
</code>

<code filename="types.bal">
```ballerina
import ballerina/time;

public type Book record {
    string id;
    string title;
    string author;
    string isbn;
    decimal price;
};

public type BookRequest record {
    string title;
    string author;
    string isbn;
    decimal price;
};

public type BookCategory record {
    string categoryId;
    string categoryName;
    string description?;
};

public type BookSearchCriteria record {
    string? title;
    string? author;
    string? isbn;
    decimal? minPrice;
    decimal? maxPrice;
};

public type PaginatedBooks record {
    Book[] books;
    int totalCount;
    int currentPage;
    int totalPages;
};

public type HealthStatus record {
    string status;
    time:Utc timestamp;
    string serviceName;
    string version;
};

public type ServiceStats record {
    int totalRequests;
    decimal uptimeSeconds;
    int totalBooks;
    int totalCategories;
    boolean debugMode;
};

public type ServiceInfo record {
    string serviceName;
    int servicePort;
    int maxBooksPerPage;
    time:Utc startTime;
};
```
</code>