I'll add a new HTTP server to the current implementation. Looking at the existing code, there are already two services (`/bookstore` and `/admin`) running on the same port. I'll create a new independent HTTP server running on a different port with its own service.

The new server will be a reporting service that provides analytics and reporting capabilities for the bookstore system, running on port 8081.

<code filename="main.bal">
```ballerina
import ballerina/http;
import ballerina/time;
import ballerina/uuid;

configurable int servicePort = 8080;
configurable int reportingServicePort = 8081;
configurable string serviceName = "Bookstore API";
configurable string reportingServiceName = "Bookstore Reporting Service";
configurable int maxBooksPerPage = 10;
configurable boolean debugMode = false;

int totalRequests = 0;
int reportingRequests = 0;
time:Utc serviceStartTime = time:utcNow();
map<BookCategory> bookCategories = {};
map<Book> bookStore = {};

service /bookstore on new http:Listener(servicePort) {

    resource function get books(int page = 1, int 'limit = maxBooksPerPage) returns PaginatedBooks|http:InternalServerError {
        totalRequests += 1;

        Book[] allBooks = bookStore.toArray();
        int totalCount = allBooks.length();
        int startIndex = (page - 1) * 'limit;
        int endIndex = startIndex + 'limit;

        if startIndex >= totalCount {
            PaginatedBooks emptyResult = {
                books: [],
                totalCount: totalCount,
                currentPage: page,
                totalPages: (totalCount + 'limit - 1) / 'limit
            };
            return emptyResult;
        }

        if endIndex > totalCount {
            endIndex = totalCount;
        }

        Book[] paginatedBooks = [];
        int index = startIndex;
        while index < endIndex {
            paginatedBooks.push(allBooks[index]);
            index += 1;
        }

        PaginatedBooks result = {
            books: paginatedBooks,
            totalCount: totalCount,
            currentPage: page,
            totalPages: (totalCount + 'limit - 1) / 'limit
        };

        return result;
    }

    resource function get books/[string bookId]() returns Book|http:NotFound|http:InternalServerError {
        totalRequests += 1;

        if bookStore.hasKey(k = bookId) {
            Book book = bookStore.get(k = bookId);
            return book;
        }
        return http:NOT_FOUND;
    }

    resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        Book|error validatedBook = validateAndFormatBook(bookRequest);
        if validatedBook is error {
            return http:BAD_REQUEST;
        }

        bookStore[validatedBook.id] = validatedBook;
        return http:CREATED;
    }

    resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|http:NotFound|http:BadRequest|http:InternalServerError {
        totalRequests += 1;

        if !bookStore.hasKey(k = bookId) {
            return http:NOT_FOUND;
        }

        Book updatedBook = {
            id: bookId,
            title: bookRequest.title,
            author: bookRequest.author,
            isbn: bookRequest.isbn,
            price: bookRequest.price,
            quantity: bookRequest.quantity
        };

        bookStore[bookId] = updatedBook;
        return updatedBook;
    }

    resource function delete books/[string bookId]() returns http:NoContent|http:NotFound|http:InternalServerError {
        totalRequests += 1;

        if !bookStore.hasKey(k = bookId) {
            return http:NOT_FOUND;
        }

        Book removedBook = bookStore.remove(k = bookId);
        return http:NO_CONTENT;
    }

    resource function post books/search(@http:Payload BookSearchCriteria searchCriteria) returns Book[]|http:InternalServerError {
        totalRequests += 1;

        Book[] allBooks = bookStore.toArray();
        Book[] filteredBooks = [];

        foreach Book book in allBooks {
            boolean matches = true;

            string? titleCriteria = searchCriteria.title;
            if titleCriteria is string {
                if !book.title.toLowerAscii().includes(titleCriteria.toLowerAscii()) {
                    matches = false;
                }
            }

            string? authorCriteria = searchCriteria.author;
            if authorCriteria is string && matches {
                if !book.author.toLowerAscii().includes(authorCriteria.toLowerAscii()) {
                    matches = false;
                }
            }

            string? isbnCriteria = searchCriteria.isbn;
            if isbnCriteria is string && matches {
                if !book.isbn.includes(isbnCriteria) {
                    matches = false;
                }
            }

            decimal? minPriceCriteria = searchCriteria.minPrice;
            if minPriceCriteria is decimal && matches {
                if book.price < minPriceCriteria {
                    matches = false;
                }
            }

            decimal? maxPriceCriteria = searchCriteria.maxPrice;
            if maxPriceCriteria is decimal && matches {
                if book.price > maxPriceCriteria {
                    matches = false;
                }
            }

            if matches {
                filteredBooks.push(book);
            }
        }

        return filteredBooks;
    }

    resource function get health() returns map<string> {
        totalRequests += 1;
        return {"status": "UP", "service": serviceName};
    }
}

service /admin on new http:Listener(servicePort) {

    resource function get stats() returns ServiceStats {
        totalRequests += 1;

        string startTimeString = time:utcToString(serviceStartTime);

        ServiceStats stats = {
            totalRequests: totalRequests,
            totalBooks: bookStore.length(),
            serviceStartTime: startTimeString,
            serviceName: serviceName,
            debugMode: debugMode
        };

        return stats;
    }

    resource function post categories(@http:Payload BookCategory category) returns http:Created|http:BadRequest {
        totalRequests += 1;

        if category.categoryName.trim().length() == 0 {
            return http:BAD_REQUEST;
        }

        bookCategories[category.categoryId] = category;
        return http:CREATED;
    }

    resource function get categories() returns BookCategory[] {
        totalRequests += 1;
        return bookCategories.toArray();
    }
}

service /reports on new http:Listener(reportingServicePort) {

    resource function get overview() returns ReportOverview {
        reportingRequests += 1;

        Book[] allBooks = bookStore.toArray();
        decimal totalValue = 0.0d;
        int totalQuantity = 0;

        foreach Book book in allBooks {
            totalValue += book.price * <decimal>book.quantity;
            totalQuantity += book.quantity;
        }

        string startTimeString = time:utcToString(serviceStartTime);

        ReportOverview overview = {
            totalBooks: bookStore.length(),
            totalCategories: bookCategories.length(),
            totalInventoryValue: totalValue,
            totalQuantity: totalQuantity,
            totalApiRequests: totalRequests,
            totalReportingRequests: reportingRequests,
            serviceStartTime: startTimeString,
            serviceName: reportingServiceName
        };

        return overview;
    }

    resource function get books/summary() returns BookSummary[] {
        reportingRequests += 1;

        Book[] allBooks = bookStore.toArray();
        BookSummary[] summaries = [];

        foreach Book book in allBooks {
            decimal totalValue = book.price * <decimal>book.quantity;
            
            BookSummary summary = {
                id: book.id,
                title: book.title,
                author: book.author,
                price: book.price,
                quantity: book.quantity,
                totalValue: totalValue
            };

            summaries.push(summary);
        }

        return summaries;
    }

    resource function get authors() returns AuthorReport[] {
        reportingRequests += 1;

        Book[] allBooks = bookStore.toArray();
        map<AuthorReport> authorMap = {};

        foreach Book book in allBooks {
            string author = book.author;
            
            if authorMap.hasKey(k = author) {
                AuthorReport existingReport = authorMap.get(k = author);
                existingReport.bookCount += 1;
                existingReport.totalQuantity += book.quantity;
                existingReport.totalValue += book.price * <decimal>book.quantity;
                authorMap[author] = existingReport;
            } else {
                AuthorReport newReport = {
                    authorName: author,
                    bookCount: 1,
                    totalQuantity: book.quantity,
                    totalValue: book.price * <decimal>book.quantity
                };
                authorMap[author] = newReport;
            }
        }

        return authorMap.toArray();
    }

    resource function get health() returns map<string> {
        reportingRequests += 1;
        return {"status": "UP", "service": reportingServiceName};
    }
}

function validateAndFormatBook(BookRequest bookRequest) returns Book|error {
    if bookRequest.title.trim().length() == 0 {
        return error("Book title cannot be empty");
    }

    if bookRequest.author.trim().length() == 0 {
        return error("Book author cannot be empty");
    }

    if bookRequest.price < 0.0d {
        return error("Book price cannot be negative");
    }

    if bookRequest.quantity < 0 {
        return error("Book quantity cannot be negative");
    }

    string bookId = uuid:createType1AsString();

    Book validatedBook = {
        id: bookId,
        title: bookRequest.title.trim(),
        author: bookRequest.author.trim(),
        isbn: bookRequest.isbn.trim(),
        price: bookRequest.price,
        quantity: bookRequest.quantity
    };

    return validatedBook;
}
```
</code>

<code filename="types.bal">
```ballerina
public type Book record {|
    string id;
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type BookRequest record {|
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

public type ErrorResponse record {|
    string message;
|};

public type PaginatedBooks record {|
    Book[] books;
    int totalCount;
    int currentPage;
    int totalPages;
|};

public type BookSearchCriteria record {|
    string? title;
    string? author;
    string? isbn;
    decimal? minPrice;
    decimal? maxPrice;
|};

public type ServiceStats record {|
    int totalRequests;
    int totalBooks;
    string serviceStartTime;
    string serviceName;
    boolean debugMode;
|};

public type BookCategory record {|
    string categoryId;
    string categoryName;
    string description;
|};

public type ReportOverview record {|
    int totalBooks;
    int totalCategories;
    decimal totalInventoryValue;
    int totalQuantity;
    int totalApiRequests;
    int totalReportingRequests;
    string serviceStartTime;
    string serviceName;
|};

public type BookSummary record {|
    string id;
    string title;
    string author;
    decimal price;
    int quantity;
    decimal totalValue;
|};

public type AuthorReport record {|
    string authorName;
    int bookCount;
    int totalQuantity;
    decimal totalValue;
|};
```
</code>