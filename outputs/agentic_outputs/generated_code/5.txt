=== QUERY ID 5 ===
Standardize the error responses so they always return a JSON object with an error message (e.g., { \"error\": \"Book not found\" }) instead of just plain HTTP status codes.

=== API DOC USED ===
api_docs/5.json

=== EXTRACTED CODE USED ===
outputs/agentic_outputs/expand_code/5.md

=== TOKEN USAGE ===
{
  "langLibs": 13563,
  "apiDocs": 5570,
  "balMdContent": 1428,
  "extractedCode": 448,
  "userQuery": 48,
  "systemPrompt": 21836,
  "generatedCode": 1983,
  "totalInput": 22346,
  "toolCalls": 14
}

=== GENERATED CODE RESPONSE ===
Based on the extracted code, I can see that the current error handling returns plain HTTP status codes like `http:NOT_FOUND`, `http:BAD_REQUEST`, etc. I need to standardize these to return JSON objects with error messages using the existing `ErrorResponse` type.

Let me modify the code to standardize all error responses:

<code filename="main.bal">
```ballerina
// Get all books with pagination
resource function get books(int page = 1, int 'limit = maxBooksPerPage) returns PaginatedBooks|ErrorResponse {
    totalRequests += 1;

    if page < 1 {
        return {message: "Page number must be greater than 0"};
    }

    if 'limit < 1 || 'limit > maxBooksPerPage {
        return {message: string`Limit must be between 1 and ${maxBooksPerPage}`};
    }

    Book[] allBooks = bookStore.toArray();
    int totalCount = allBooks.length();
    int totalPages = (totalCount + 'limit - 1) / 'limit;

    if page > totalPages && totalCount > 0 {
        return {message: "Page number exceeds total pages"};
    }

    int startIndex = (page - 1) * 'limit;
    int endIndex = startIndex + 'limit;
    if endIndex > totalCount {
        endIndex = totalCount;
    }

    Book[] paginatedBooks = [];
    int index = startIndex;
    while index < endIndex {
        paginatedBooks.push(allBooks[index]);
        index += 1;
    }

    return {
        books: paginatedBooks,
        totalCount: totalCount,
        currentPage: page,
        totalPages: totalPages
    };
}

// Get a specific book by ID
resource function get books/[string bookId]() returns Book|ErrorResponse {
    totalRequests += 1;

    if bookStore.hasKey(k = bookId) {
        Book book = bookStore.get(k = bookId);
        return book;
    }
    return {message: "Book not found"};
}

// Add a new book
resource function post books(@http:Payload BookRequest bookRequest) returns http:Created|ErrorResponse {
    totalRequests += 1;

    Book|error validatedBook = validateAndFormatBook(bookRequest);
    if validatedBook is error {
        return {message: validatedBook.message()};
    }

    bookStore[validatedBook.id] = validatedBook;
    return http:CREATED;
}

// Update an existing book
resource function put books/[string bookId](@http:Payload BookRequest bookRequest) returns Book|ErrorResponse {
    totalRequests += 1;

    if !bookStore.hasKey(k = bookId) {
        return {message: "Book not found"};
    }

    Book|error validatedBook = validateAndFormatBook(bookRequest);
    if validatedBook is error {
        return {message: validatedBook.message()};
    }

    // Keep the original ID
    Book updatedBook = {
        id: bookId,
        title: validatedBook.title,
        author: validatedBook.author,
        isbn: validatedBook.isbn,
        price: validatedBook.price,
        quantity: validatedBook.quantity
    };

    bookStore[bookId] = updatedBook;
    return updatedBook;
}

// Delete a book
resource function delete books/[string bookId]() returns http:NoContent|ErrorResponse {
    totalRequests += 1;

    if !bookStore.hasKey(k = bookId) {
        return {message: "Book not found"};
    }

    _ = bookStore.remove(k = bookId);
    return http:NO_CONTENT;
}

// Search books based on criteria
resource function post books/search(@http:Payload BookSearchCriteria searchCriteria) returns Book[]|ErrorResponse {
    totalRequests += 1;

    Book[] allBooks = bookStore.toArray();
    Book[] matchingBooks = [];

    foreach Book book in allBooks {
        boolean matches = true;

        if searchCriteria.title is string && !book.title.toLowerAscii().includes(searchCriteria.title.toLowerAscii()) {
            matches = false;
        }

        if searchCriteria.author is string && !book.author.toLowerAscii().includes(searchCriteria.author.toLowerAscii()) {
            matches = false;
        }

        if searchCriteria.isbn is string && book.isbn != searchCriteria.isbn {
            matches = false;
        }

        if searchCriteria.minPrice is decimal && book.price < searchCriteria.minPrice {
            matches = false;
        }

        if searchCriteria.maxPrice is decimal && book.price > searchCriteria.maxPrice {
            matches = false;
        }

        if matches {
            matchingBooks.push(book);
        }
    }

    return matchingBooks;
}

// Create a new category
resource function post categories(@http:Payload BookCategory category) returns http:Created|ErrorResponse {
    if category.categoryName.trim().length() == 0 {
        return {message: "Category name cannot be empty"};
    }

    if category.categoryId.trim().length() == 0 {
        return {message: "Category ID cannot be empty"};
    }

    if bookCategories.hasKey(k = category.categoryId) {
        return {message: "Category with this ID already exists"};
    }

    bookCategories[category.categoryId] = category;
    return http:CREATED;
}
```
</code>

Now I also need to update the function signatures and return types to ensure consistency:

<code filename="types.bal">
```ballerina
// Book entity
public type Book record {|
    string id;
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

// Request payload for creating/updating books
public type BookRequest record {|
    string title;
    string author;
    string isbn;
    decimal price;
    int quantity;
|};

// Standardized error response
public type ErrorResponse record {|
    string message;
|};

// Paginated books response
public type PaginatedBooks record {|
    Book[] books;
    int totalCount;
    int currentPage;
    int totalPages;
|};

// Search criteria for books
public type BookSearchCriteria record {|
    string? title = ();
    string? author = ();
    string? isbn = ();
    decimal? minPrice = ();
    decimal? maxPrice = ();
|};

// Service statistics
public type ServiceStats record {|
    int totalRequests;
    int totalBooks;
    string serviceStartTime;
    string serviceName;
    boolean debugMode;
|};

// Book category
public type BookCategory record {|
    string categoryId;
    string categoryName;
    string description;
|};
```
</code>

The key changes I made to standardize error responses:

1. **Replaced all HTTP status code returns** with `ErrorResponse` type that contains a descriptive error message
2. **Updated return types** in function signatures to use `ErrorResponse` instead of HTTP status codes like `http:NotFound`, `http:BadRequest`, etc.
3. **Added meaningful error messages** for different error scenarios:
   - "Book not found" for missing books
   - "Page number must be greater than 0" for invalid pagination
   - "Category name cannot be empty" for validation errors
   - Error messages from validation functions are passed through using `validatedBook.message()`

4. **Kept successful responses unchanged** - only error cases now return JSON objects
5. **Maintained HTTP status codes** for successful operations (like `http:CREATED`, `http:NO_CONTENT`) since these don't need error messages

Now all error responses will be consistent JSON objects with the structure `{"message": "descriptive error message"}`, making the API more user-friendly and easier to consume by client applications.

